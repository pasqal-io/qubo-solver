{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qubo Solver","text":"<p>Solving combinatorial optimization (CO) problems using quantum computing is one of those promising applications for the near term. The Quadratic Unconstrained Binary Optimization (QUBO) (also known as unconstrained binary quadratic programming) model enables to formulate many CO problems that can be tackled using quantum hardware. QUBO offers a wide range of applications from finance and economics to machine learning. The Qubo Solver is a Python library designed for solving Quadratic Unconstracined Binary Optimization (QUBO) problems on a neutral atom quantum processor.</p> <p>The core of the library is focused on the development of several algorithms for solving QUBOs: classical (tabu-search, simulated annealing, ...), quantum (Variational Quantum Algorithms, Quantum Adiabatic Algorithm, ...) or hybrid quantum-classical.</p> <p>Users setting their first steps into quantum computing will learn how to implement the core algorithm in a few simple steps and run it using the Pasqal Neutral Atom QPU. More experienced users will find this library to provide the right environment to explore new ideas - both in terms of methodologies and data domain - while always interacting with a simple and intuitive QPU interface.</p>"},{"location":"#development-tools","title":"Development tools","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#install-as-a-dependency","title":"Install as a dependency","text":"<p>Using <code>hatch</code>, <code>uv</code> or any pyproject-compatible Python manager</p> <p>Edit file <code>pyproject.toml</code> to add the line</p> <pre><code>  \"qubo-solver\"\n</code></pre>"},{"location":"#using-pip-or-pipx","title":"Using <code>pip</code> or <code>pipx</code>","text":"<p>To install the <code>pipy</code> package using <code>pip</code> or <code>pipx</code></p> <ol> <li>Create a <code>venv</code> if that's not done yet</li> </ol> <pre><code>$ python -m venv venv\n</code></pre> <ol> <li>Enter the venv</li> </ol> <pre><code>$ . venv/bin/activate\n</code></pre> <ol> <li>Install the package</li> </ol> <pre><code>$ pip install qubo-solver\n# or\n$ pipx install qubo-solver\n</code></pre> <p>Alternatively, you can also:</p> <ul> <li>install with <code>pip</code> in development mode by simply running <code>pip install -e .</code>. Notice that in this way   you will install all the dependencies, including extras.</li> <li>install it with <code>conda</code> by simply using <code>pip</code> inside the Conda environment.</li> </ul>"},{"location":"#install-on-windows","title":"Install on Windows","text":"<p>Note the package is not compatible with Windows systems. We recommend using the Windows Subsystem for Linux (WSL).</p>"},{"location":"#cplex-installation","title":"Cplex Installation","text":"<p>The <code>cplex</code> dependency may cause installation problems. We recommend using python <code>3.11</code> or try another supported version when installing <code>qubo-solver</code>. If you wish to use the licensed version of CPLEX, it is required to set the environment variable <code>ILOG_LICENSE_FILE</code> to the location of the license file.</p>"},{"location":"#quickstart","title":"QuickStart","text":""},{"location":"#with-a-quantum-solver","title":"With a quantum solver","text":"<pre><code>from qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig\nfrom qubosolver.solver import QuboSolver\nfrom qoolqit._solvers.data import BackendConfig\nfrom qoolqit._solvers.types import BackendType\n\n# define QUBO\nQ = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\ninstance = QUBOInstance(coefficients=Q)\n\n# Create a SolverConfig object to use a quantum backend\nconfig = SolverConfig(use_quantum=True, backend_config = BackendConfig(backend=BackendType.QUTIP))\n\n# Instantiate the quantum solver.\nsolver = QuboSolver(instance, config)\n\n# Solve the QUBO problem.\nsolution = solver.solve()\n</code></pre>"},{"location":"#with-a-classical-solver","title":"With a classical solver","text":"<pre><code>from qubosolver import QUBOInstance\nfrom qubosolver.config import ClassicalConfig, SolverConfig\nfrom qubosolver.solver import QuboSolverClassical, QuboSolverQuantum\n\n# define QUBO\nQ = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\ninstance = QUBOInstance(coefficients=Q)\n\n# Create a SolverConfig object with classical solver options.\nclassical_config = ClassicalConfig(\n    classical_solver_type=\"cplex\",\n    cplex_maxtime=10.0,\n    cplex_log_path=\"test_solver.log\",\n)\nconfig = SolverConfig(use_quantum=False, classical=classical_config)\n\n# Instantiate the classical solver via the pipeline's classical solver dispatcher.\nclassical_solver = QuboSolver(instance, config)\n\n# Solve the QUBO problem.\nsolution = classical_solver.solve()\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Documentation</li> <li>Notebooks Tutorials.</li> <li>Full API documentation.</li> </ul>"},{"location":"#getting-in-touch","title":"Getting in touch","text":"<ul> <li>Pasqal Community Portal (forums, chat, tutorials, examples, code library).</li> <li>Github repository (source code, issue tracker).</li> <li>Professional Support (if you need tech support, custom licenses, a variant of this library optimized for your workload, your own QPU, remote access to a QPU, ...)</li> </ul>"},{"location":"CONTRIBUTOR%20AGREEMENT/","title":"Contributor Agreement","text":"<p>PASQAL CONTRIBUTION AGREEMENT (the \u201cAgreement\u201d)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <p>In the course of its activities, Pasqal carries out and leads quantic projects, in their software components. These projects aim to bring together a community of like-minded individuals to contribute to the development and improvement of Pasqal\u2019s products. Pasqal clearly outlines which projects are open to contributions (\u201cProjects\u201d).</p> <p>This Agreement documents the rights granted by Contributors to Pasqal and is legally binding.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-1-definitions","title":"Article 1 Definitions","text":"<p>You, Your or Contributor : means the intellectual property rights owner or legal entity authorized by the intellectual property rights owner that is entering into this Agreement with\u00a0Pasqal</p> <p>Contribution : means any work, protected or not, that is submitted by You to Pasqal in which You own or assert ownership of the intellectual property rights, subject to proprietary licensing terms, and not otherwise distributer through an open-source license.</p> <p>Material : means the work object of the Project, made available by Pasqal to third parties. When this Agreement covers more than one Project, the Material means the work to which the Contribution was Submitted. After You Submit the Contribution, it may be included in any type of Material.</p> <p>Submit : means any form of electronic, verbal, or written communication sent to Pasqal or its representatives, including but not limited to electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Pasqal for the purpose of discussing and improving the Material.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-2-entering-into-this-agreement","title":"Article 2 Entering into this Agreement","text":"<p>By Submitting any Contribution to Pasqal, You agree to enter into the Agreement with this entity, and be bound by the following terms.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-3-limitations-as-to-the-licensing-of-contributions","title":"Article 3 Limitations as to the licensing of Contributions","text":"<p>You guarantee that any Contribution You Submit to any Project is not licensed under any type of contaminating (even weakly contaminating) license, and that Pasqal will be free to combine your Contribution into any type of Material, for any Project, without any risk of contamination of said Material and/or Project.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-4-granting-of-a-copyright-andor-authors-rights-license","title":"Article 4 Granting of a Copyright and/or author\u2019s rights License","text":"<p>Subject to the terms and conditions of this Agreement, You hereby grant to Pasqal and to recipients of any Project distributed by Pasqal a worldwide, sublicensable, non-exclusive, royalty-free license to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute Your Contributions and your Contribution in combination with the Material for the entire duration of the rights under Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-5-granting-of-a-patent-license","title":"Article 5 Granting of a patent license","text":"<p>Subject to the terms and conditions of this Agreement, You grant Pasqal a, worldwide, non-exclusive, transferable, royalty free patent license, with the right to sublicense these rights to third parties, to make, have made, use, sell, offer for sale, import and otherwise  transfer the Contribution and the Contribution in combination with the Material for the entire duration of the rights under Applicable law, if the Contribution implies the implementation of any such patent.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-6-licensing-of-the-material-and-contribution","title":"Article 6 Licensing of the Material and Contribution","text":"<p>Based on the rights granted in articles 2 and 3, if Pasqal includes Your Contribution in a Material, Pasqal may license Material including Your Contribution under any license, whether permissive, weakly contaminating, or contaminating. Pasqal will respect Your moral rights in relation to Your Contribution as provided under the Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-7-warranties-and-disclaimer","title":"Article 7 Warranties and disclaimer","text":"<p>You represent that each of Your Contributions is Your creation, or that you have obtained the authorization from the intellectual property rights owner on the Contribution to Submit it over the course of a Project.</p> <p>By making a Contribution, You confirm that, to the best of Your knowledge, the Contribution does not violate the rights of any person or entity. If You make a Contribution on behalf of Your employer, then You confirm that an appropriate representative of that employer has authorized the inclusion of such Contribution to a Project and that it meets these requirements.</p> <p>You acknowledge that Pasqal is not obligated to use Your Contribution as part of the Material and may decide to only include Contributions Pasqal considers appropriate.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-8-applicable-law-and-jurisdiction","title":"Article 8 Applicable law and jurisdiction","text":"<p>The Agreement is governed by the laws of France. Any dispute relating to the interpretation or application of the License shall be subject to best efforts for an amicable settlement. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p>"},{"location":"LICENSE/","title":"Licence (MIT-Derived)","text":"<p>PASQAL OPEN-SOURCE SOFTWARE LICENSE AGREEMENT (MIT-derived)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <ul> <li> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the \u201cLicensee\u201d) and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software is \u201cas is\u201d, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise arising from, out of or in connection with the Software or the use or other dealings in the Software.</p> </li> <li> <p>If use of the Software leads to the necessary use of any patent of the Licensor and/or any of its Affiliates (defined as a company owned or controlled by the Licensor), the Licensee is granted a royalty-free license, in any country where such patent is in force, to use the object of such patent; or use the process covered by such patent,</p> </li> <li> <p>Such a patent license is granted for internal research or academic use of the Licensee's, which includes use by employees and students of the Licensee, acting on behalf of the Licensee, for research purposes only.</p> </li> <li> <p>The License is governed by the laws of France. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p> </li> </ul>"},{"location":"api/config/","title":"Configs","text":""},{"location":"api/config/#qubosolver.config.ClassicalConfig","title":"<code>ClassicalConfig</code>","text":"<p>               Bases: <code>Config</code></p> <p>A <code>ClassicalConfig</code> instance defines the classical     part of a <code>SolverConfig</code>.</p> ATTRIBUTE DESCRIPTION <code>classical_solver_type</code> <p>Classical solver type. Defaults to \"cplex\".</p> <p> TYPE: <code>str</code> </p> <code>cplex_maxtime</code> <p>CPLEX maximum runtime. Defaults to 600s.</p> <p> TYPE: <code>float</code> </p> <code>cplex_log_path</code> <p>CPLEX log path. Default to <code>solver.log</code>.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/config/#qubosolver.config.Config","title":"<code>Config</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Pydantic class for configs.</p>"},{"location":"api/config/#qubosolver.config.EmbeddingConfig","title":"<code>EmbeddingConfig</code>","text":"<p>               Bases: <code>Config</code></p> <p>A <code>EmbeddingConfig</code> instance defines the embedding     part of a <code>SolverConfig</code>.</p> ATTRIBUTE DESCRIPTION <code>embedding_method</code> <p>The type of embedding method used to place atoms on the register according to the QUBO problem. Defaults to <code>EmbedderType.GREEDY</code>.</p> <p> TYPE: <code>str | EmbedderType | type[BaseEmbedder]</code> </p> <code>layout_greedy_embedder</code> <p>Layout type for the greedy embedder method. Defaults to <code>LayoutType.TRIANGULAR</code>.</p> <p> TYPE: <code>LayoutType | str</code> </p> <code>blade_steps_per_round</code> <p>The number of steps for each layer of dimension for BLaDE. Defaults to 200.</p> <p> TYPE: <code>int</code> </p> <code>starting_positions</code> <p>The starting parameters according to the specified dimensions. Defaults to None.</p> <p> TYPE: <code>Tensor | None</code> </p> <code>blade_dimensions</code> <p>A list of dimension degrees to explore one after the other (default is <code>[5, 4, 3, 2, 2, 2]</code>).</p> <p> TYPE: <code>list[int]</code> </p> <code>traps</code> <p>The number of traps on the register. Defaults to <code>DeviceType.ANALOG_DEVICE.value.min_layout_traps</code>.</p> <p> TYPE: <code>int</code> </p> <code>spacing</code> <p>The minimum distance between atoms. Defaults to <code>DeviceType.ANALOG_DEVICE.value.min_atom_distance</code>.</p> <p> TYPE: <code>float</code> </p> <code>density</code> <p>The estimated density of the QUBO matrix. Defaults to None.</p> <p> TYPE: <code>float</code> </p> <code>draw_steps</code> <p>Show generated graph at each step of the optimization. Defaults to <code>False</code>.</p> <p> TYPE: <code>bool</code> </p> <code>animation_save_path</code> <p>If provided, path to save animation. Defaults to None.</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/config/#qubosolver.config.PulseShapingConfig","title":"<code>PulseShapingConfig</code>","text":"<p>               Bases: <code>Config</code></p> <p>A <code>PulseShapingConfig</code> instance defines the pulse shaping     part of a <code>SolverConfig</code>.</p> ATTRIBUTE DESCRIPTION <code>pulse_shaping_method</code> <p>Pulse shaping method used. Defauts to <code>PulseType.ADIABATIC</code>.</p> <p> TYPE: <code>str | PulseType | type[BasePulseShaper]</code> </p> <code>initial_omega_parameters</code> <p>Default initial omega parameters for the pulse. Defaults to Omega = (5, 10, 5).</p> <p> TYPE: <code>List[float]</code> </p> <code>initial_detuning_parameters</code> <p>Default initial detuning parameters for the pulse. Defaults to delta = (-10, 0, 10).</p> <p> TYPE: <code>List[float]</code> </p> <code>re_execute_opt_pulse</code> <p>Whether to re-run the optimal pulse sequence. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>custom_qubo_cost</code> <p>Apply a different qubo cost evaluation than the default QUBO evaluation defined in <code>qubosolver/pipeline/pulse.py:OptimizedPulseShaper.compute_qubo_cost</code>. Must be defined as: <code>def custom_qubo_cost(bitstring: str, QUBO: torch.Tensor) -&gt; float</code>. Defaults to None, meaning we use the default QUBO evaluation.</p> <p> TYPE: <code>Callable[[str, Tensor], float]</code> </p> <code>custom_objective_fn</code> <p>For bayesian optimization, one can change the output of <code>qubosolver/pipeline/pulse.py:OptimizedPulseShaper.run_simulation</code> to optimize differently. Instead of using the best cost out of the samples, one can change the objective for an average, or any function out of the form <code>cost_eval = custom_objective_fn(bitstrings,     counts, probabilities, costs, best_cost, best_bitstring)</code> Defaults to None, which means we optimize using the best cost out of the samples.</p> <p> TYPE: <code>Callable[[list, list, list, list, float, str], float]</code> </p> <code>callback_objective</code> <p>Apply a callback during bayesian optimization. Only accepts one input dictionary created during optimization <code>d = {\"x\": x, \"cost_eval\": cost_eval}</code> hence should be defined as: <code>def callback_fn(d: dict) -&gt; None:</code> Defaults to None, which means no callback is applied.</p> <p> TYPE: <code>Callable[..., None]</code> </p>"},{"location":"api/config/#qubosolver.config.SolverConfig","title":"<code>SolverConfig</code>","text":"<p>               Bases: <code>Config</code></p> <p>A <code>SolverConfig</code> instance defines how a QUBO problem should be solved. We specify whether to use a quantum or classical approach, which backend to run on, and additional execution parameters.</p> ATTRIBUTE DESCRIPTION <code>config_name</code> <p>The name of the current configuration. Defaults to ''.</p> <p> TYPE: <code>str</code> </p> <code>use_quantum</code> <p>Whether to solve using a quantum approach (<code>True</code>) or a classical approach (<code>False</code>). Defaults to False.</p> <p> TYPE: <code>bool</code> </p> <code>backend</code> <p>Which underlying backend configuration is used. Defaults to the default BackendConfig using <code>BackendType.QUTIP</code>.</p> <p> TYPE: <code>BackendConfig</code> </p> <code>n_calls</code> <p>Number of calls for the optimization process inside VQA. Defaults to 20. Note the optimizer accepts a minimal value of 12.</p> <p> TYPE: <code>int</code> </p> <code>embedding</code> <p>Embedding part configuration of the solver.</p> <p> TYPE: <code>EmbeddingConfig</code> </p> <code>pulse_shaping</code> <p>Pulse-shaping part configuration of the solver.</p> <p> TYPE: <code>PulseShapingConfig</code> </p> <code>classical</code> <p>Classical part configuration of the solver.</p> <p> TYPE: <code>ClassicalConfig</code> </p> <code>num_shots</code> <p>Number of samples. Defaults to 500.</p> <p> TYPE: <code>int</code> </p> <code>do_postprocessing</code> <p>Whether we apply post-processing (<code>True</code>) or not (<code>False</code>).</p> <p> TYPE: <code>bool</code> </p> <code>do_preprocessing</code> <p>Whether we apply pre-processing (<code>True</code>) or not (<code>False</code>)</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/config/#qubosolver.config.SolverConfig.from_kwargs","title":"<code>from_kwargs(**kwargs)</code>  <code>classmethod</code>","text":"<p>Create an instance based on entries of other configs.</p> <p>Note that if any of the keywords (\"backend_config\", \"embedding\", \"pulse_shaping\", \"classical\") are present in kwargs, the values are taken directly.</p> RETURNS DESCRIPTION <code>SolverConfig</code> <p>An instance from values.</p> <p> TYPE: <code>SolverConfig</code> </p> Source code in <code>qubosolver/config.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: dict) -&gt; SolverConfig:\n    \"\"\"Create an instance based on entries of other configs.\n\n    Note that if any of the keywords\n    (\"backend_config\", \"embedding\", \"pulse_shaping\", \"classical\")\n    are present in kwargs, the values are taken directly.\n\n    Returns:\n        SolverConfig: An instance from values.\n    \"\"\"\n    # Extract fields from pydantic BaseModel\n    backend_config_fields = {k: v for k, v in kwargs.items() if k in BackendConfig.model_fields}\n    embedding_fields = {k: v for k, v in kwargs.items() if k in EmbeddingConfig.model_fields}\n    pulse_shaping_fields = {\n        k: v for k, v in kwargs.items() if k in PulseShapingConfig.model_fields\n    }\n    classical_fields = {k: v for k, v in kwargs.items() if k in ClassicalConfig.model_fields}\n\n    solver_fields = {\n        k: v\n        for k, v in kwargs.items()\n        if k in cls.model_fields\n        and k not in (\"backend_config\", \"embedding\", \"pulse_shaping\", \"classical\")\n    }\n\n    return cls(\n        backend_config=(\n            BackendConfig(**backend_config_fields)\n            if \"backend_config\" not in kwargs\n            else kwargs[\"backend_config\"]\n        ),\n        embedding=(\n            EmbeddingConfig(**embedding_fields)\n            if \"embedding\" not in kwargs\n            else kwargs[\"embedding\"]\n        ),\n        pulse_shaping=(\n            PulseShapingConfig(**pulse_shaping_fields)\n            if \"pulse_shaping\" not in kwargs\n            else kwargs[\"pulse_shaping\"]\n        ),\n        classical=(\n            ClassicalConfig(**classical_fields)\n            if \"classical\" not in kwargs\n            else kwargs[\"classical\"]\n        ),\n        **solver_fields,\n    )\n</code></pre>"},{"location":"api/config/#qubosolver.config.SolverConfig.print_specs","title":"<code>print_specs()</code>","text":"<p>Print specs.</p> Source code in <code>qubosolver/config.py</code> <pre><code>def print_specs(self) -&gt; None:\n    \"\"\"Print specs.\"\"\"\n    print(self._specs())\n</code></pre>"},{"location":"api/data/","title":"Data","text":""},{"location":"api/data/#qubosolver.data.QUBODataset","title":"<code>QUBODataset(coefficients, solutions=None)</code>","text":"<p>               Bases: <code>Dataset</code></p> <p>Represents a dataset for Quadratic Unconstrained Binary Optimization (QUBO) problems.</p> ATTRIBUTE DESCRIPTION <code>coefficients</code> <p>Tensor of shape (size, size, num_instances), containing the QUBO coefficient matrices.</p> <p> TYPE: <code>Tensor</code> </p> <code>solutions</code> <p>Optional list of QUBOSolution objects corresponding to each instance in the dataset.</p> <p> TYPE: <code>list[QUBOSolution] | None</code> </p> METHOD DESCRIPTION <code>__len__</code> <p>Returns the number of instances in the dataset.</p> <code>__getitem__</code> <p>Retrieves the coefficient matrix and optionally the solution for the specified index.</p> <code>from_random</code> <p>Class method to generate a QUBODataset with random coefficient matrices.</p> <p>Initializes a QUBODataset.</p> PARAMETER DESCRIPTION <code>coefficients</code> <p>Tensor of shape (size, size, num_instances), containing the QUBO coefficient matrices.</p> <p> TYPE: <code>Tensor</code> </p> <code>solutions</code> <p>Optional list of QUBOSolution objects corresponding to each instance in the dataset.</p> <p> TYPE: <code>list[QUBOSolution] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qubosolver/data.py</code> <pre><code>def __init__(self, coefficients: torch.Tensor, solutions: list[QUBOSolution] | None = None):\n    \"\"\"\n    Initializes a QUBODataset.\n\n    Args:\n        coefficients (torch.Tensor):\n            Tensor of shape (size, size, num_instances), containing the QUBO\n            coefficient matrices.\n        solutions (list[QUBOSolution] | None):\n            Optional list of QUBOSolution objects corresponding to each instance\n            in the dataset.\n    \"\"\"\n    self.coefficients = coefficients\n    self.solutions = solutions\n</code></pre>"},{"location":"api/data/#qubosolver.data.QUBODataset.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Retrieves the coefficient matrix and optionally the solution for the specified index.</p> PARAMETER DESCRIPTION <code>idx</code> <p>Index of the dataset instance to retrieve.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>tuple[Tensor, QUBOSolution | None]</code> <p>tuple[torch.Tensor, QUBOSolution | None]: The coefficient matrix of shape (size, size) and optionally the corresponding QUBOSolution.</p> Source code in <code>qubosolver/data.py</code> <pre><code>def __getitem__(self, idx: int) -&gt; tuple[torch.Tensor, QUBOSolution | None]:\n    \"\"\"\n    Retrieves the coefficient matrix and optionally the solution for the specified index.\n\n    Args:\n        idx (int):\n            Index of the dataset instance to retrieve.\n\n    Returns:\n        tuple[torch.Tensor, QUBOSolution | None]:\n            The coefficient matrix of shape (size, size) and optionally\n            the corresponding QUBOSolution.\n    \"\"\"\n    if self.solutions is not None:\n        return self.coefficients[:, :, idx], self.solutions[idx]\n    return self.coefficients[:, :, idx], None\n</code></pre>"},{"location":"api/data/#qubosolver.data.QUBODataset.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of instances in the dataset.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of coefficient matrices (num_instances).</p> <p> TYPE: <code>int</code> </p> Source code in <code>qubosolver/data.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Returns the number of instances in the dataset.\n\n    Returns:\n        int: The number of coefficient matrices (num_instances).\n    \"\"\"\n    return int(self.coefficients.shape[2])\n</code></pre>"},{"location":"api/data/#qubosolver.data.QUBODataset.from_random","title":"<code>from_random(n_matrices, matrix_dim, densities=[0.5], coefficient_bounds=(-10.0, 10.0), device='cpu', dtype=torch.float32, seed=None)</code>  <code>classmethod</code>","text":"<p>Generates a QUBODataset with random QUBO coefficient matrices.</p> <p>Generation Steps: 1. Initialize a reproducible random generator. 2. Create a storage tensor for coefficients. 3. For each density:     a. Compute the exact target number of non-zero elements.     b. For each instance:         i.  Generate a symmetric boolean mask with an exact number of True elements.         ii. Generate random values within the coefficient_bounds.         iii. Apply the mask to zero out unselected elements.         iv. Symmetrize the matrix by mirroring the upper triangle onto the lower triangle.         v. Force all off-diagonal coefficients to be positive.         vi. Ensure that at least one diagonal element is negative.         vii. Ensure at least one coefficient equals the upper bound, excluding         any diagonal already at the lower bound. 4. Return a QUBODataset instance containing the generated matrices.</p> PARAMETER DESCRIPTION <code>n_matrices</code> <p>Number of QUBO matrices to generate for each density.</p> <p> TYPE: <code>int</code> </p> <code>matrix_dim</code> <p>The dimension of each QUBO matrix.</p> <p> TYPE: <code>int</code> </p> <code>densities</code> <p>List of densities (ratio of non-zero elements). Defaults to [0.5].</p> <p> TYPE: <code>list[float]</code> DEFAULT: <code>[0.5]</code> </p> <code>coefficient_bounds</code> <p>Range (min, max) of random values for the coefficients. Defaults to (-10.0, 10.0).</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>(-10.0, 10.0)</code> </p> <code>device</code> <p>Device for the tensors. Defaults to \"cpu\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>dtype</code> <p>Data type for the coefficient tensors. Defaults to torch.float32.</p> <p> TYPE: <code>dtype</code> DEFAULT: <code>float32</code> </p> <code>seed</code> <p>Seed for reproducibility. Defaults to None.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QUBODataset</code> <p>A dataset containing the generated coefficient matrices.</p> <p> TYPE: <code>QUBODataset</code> </p> Source code in <code>qubosolver/data.py</code> <pre><code>@classmethod\ndef from_random(\n    cls,\n    n_matrices: int,\n    matrix_dim: int,\n    densities: list[float] = [0.5],\n    coefficient_bounds: tuple[float, float] = (-10.0, 10.0),\n    device: str = \"cpu\",\n    dtype: torch.dtype = torch.float32,\n    seed: int | None = None,\n) -&gt; QUBODataset:\n    \"\"\"\n    Generates a QUBODataset with random QUBO coefficient matrices.\n\n    Generation Steps:\n    1. Initialize a reproducible random generator.\n    2. Create a storage tensor for coefficients.\n    3. For each density:\n        a. Compute the exact target number of non-zero elements.\n        b. For each instance:\n            i.  Generate a symmetric boolean mask with an exact number of True elements.\n            ii. Generate random values within the coefficient_bounds.\n            iii. Apply the mask to zero out unselected elements.\n            iv. Symmetrize the matrix by mirroring the upper triangle onto the lower triangle.\n            v. Force all off-diagonal coefficients to be positive.\n            vi. Ensure that at least one diagonal element is negative.\n            vii. Ensure at least one coefficient equals the upper bound, excluding\n            any diagonal already at the lower bound.\n    4. Return a QUBODataset instance containing the generated matrices.\n\n    Args:\n        n_matrices (int): Number of QUBO matrices to generate for each density.\n        matrix_dim (int): The dimension of each QUBO matrix.\n        densities (list[float], optional): List of densities (ratio of non-zero elements).\n            Defaults to [0.5].\n        coefficient_bounds (tuple[float, float], optional): Range (min, max) of\n            random values for the coefficients. Defaults to (-10.0, 10.0).\n        device (str): Device for the tensors. Defaults to \"cpu\".\n        dtype (torch.dtype, optional): Data type for the coefficient tensors.\n            Defaults to torch.float32.\n        seed (int | None, optional): Seed for reproducibility. Defaults to None.\n\n    Returns:\n        QUBODataset: A dataset containing the generated coefficient matrices.\n    \"\"\"\n    # Step 1: Initialize a reproducible random generator.\n    generator = torch.Generator(device=device)\n    if seed is not None:\n        generator.manual_seed(seed)\n\n    # Step 2: Create a tensor for the coefficients.\n    total_instances = n_matrices * len(densities)\n    coefficients = torch.zeros(\n        matrix_dim, matrix_dim, total_instances, device=device, dtype=dtype\n    )\n\n    # Step 3: Generate matrices for each density.\n    idx = 0\n    for d in densities:\n        target = int(d * matrix_dim * matrix_dim)\n        for _ in range(n_matrices):\n            mask = generate_symmetric_mask(matrix_dim, target, device, generator)\n            random_vals = torch.empty(\n                matrix_dim, matrix_dim, device=device, dtype=dtype\n            ).uniform_(*coefficient_bounds, generator=generator)\n            random_vals = random_vals * mask.to(dtype)\n\n            original_diag = random_vals.diag().clone()\n            coeff = torch.triu(random_vals, diagonal=1)\n            coeff = coeff + coeff.T\n            coeff.diagonal().copy_(original_diag)\n\n            off_diag = ~torch.eye(matrix_dim, dtype=torch.bool, device=device)\n            coeff[off_diag] = coeff[off_diag].abs()\n\n            if not (coeff.diag() &lt; 0).any():\n                diag_vals = coeff.diag()\n                non_neg = (diag_vals &gt;= 0).nonzero(as_tuple=True)[0]\n                diag_idx = (\n                    non_neg[0].item()\n                    if non_neg.numel() &gt; 0\n                    else torch.randint(\n                        0, matrix_dim, (1,), device=device, generator=generator\n                    ).item()\n                )\n                if coefficient_bounds[0] &lt; 0:\n                    neg_val = coefficient_bounds[0]\n                else:\n                    neg_val = (\n                        -torch.empty(1, device=device, dtype=dtype)\n                        .uniform_(*coefficient_bounds, generator=generator)\n                        .abs()\n                        .item()\n                    )\n                coeff[diag_idx, diag_idx] = neg_val\n\n            if not (coeff == coefficient_bounds[1]).any():\n                nz = (coeff != 0).nonzero(as_tuple=False)\n                filtered = [\n                    idx_pair\n                    for idx_pair in nz.tolist()\n                    if not (\n                        idx_pair[0] == idx_pair[1]\n                        and coeff[idx_pair[0], idx_pair[1]].item() == coefficient_bounds[0]\n                    )\n                ]\n                if filtered:\n                    chosen = filtered[\n                        torch.randint(\n                            0,\n                            len(filtered),\n                            (1,),\n                            device=device,\n                            generator=generator,\n                        ).item()\n                    ]\n                else:\n                    chosen = [\n                        torch.randint(\n                            0, matrix_dim, (1,), device=device, generator=generator\n                        ).item()\n                    ] * 2\n                i_ch, j_ch = chosen\n                coeff[i_ch, j_ch] = coefficient_bounds[1]\n                if i_ch != j_ch:\n                    coeff[j_ch, i_ch] = coefficient_bounds[1]\n\n            coefficients[:, :, idx] = coeff\n            idx += 1\n\n    # Step 4: Return the dataset.\n    return cls(coefficients=coefficients)\n</code></pre>"},{"location":"api/data/#qubosolver.data.QUBOSolution","title":"<code>QUBOSolution(bitstrings, costs, counts=None, probabilities=None, solution_status=SolutionStatusType.UNPROCESSED)</code>  <code>dataclass</code>","text":"<p>Represents a solution to a QUBO problem.</p> ATTRIBUTE DESCRIPTION <code>bitstrings</code> <p>Tensor of shape (num_solutions, bitstring_length), containing the bitstring solutions. Each entry is an integer tensor with 0s and 1s.</p> <p> TYPE: <code>Tensor</code> </p> <code>counts</code> <p>Tensor of shape (num_solutions,), containing the count of occurrences of each bitstring. Optional, can be None.</p> <p> TYPE: <code>Tensor | None</code> </p> <code>probabilities</code> <p>Tensor of shape (num_solutions,), containing the probability of each bitstring solution. Optional, can be None.</p> <p> TYPE: <code>Tensor | None</code> </p> <code>costs</code> <p>Tensor of shape (num_solutions,), containing the cost associated with each bitstring solution.</p> <p> TYPE: <code>Tensor</code> </p>"},{"location":"api/data/#qubosolver.data.QUBOSolution.compute_costs","title":"<code>compute_costs(instance)</code>","text":"<p>Computes the cost for each bitstring solution based on the provided QUBO instance.</p> PARAMETER DESCRIPTION <code>instance</code> <p>The QUBO instance containing the QUBO matrix.</p> <p> TYPE: <code>QUBOInstance</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>torch.Tensor: A tensor of costs for each bitstring.</p> Source code in <code>qubosolver/data.py</code> <pre><code>def compute_costs(self, instance: Any) -&gt; torch.Tensor:\n    \"\"\"\n    Computes the cost for each bitstring solution based on the provided QUBO instance.\n\n    Args:\n        instance (QUBOInstance): The QUBO instance containing the QUBO matrix.\n\n    Returns:\n        torch.Tensor: A tensor of costs for each bitstring.\n    \"\"\"\n    # Retrieve the QUBO matrix from the QUBOInstance\n    QUBO = instance.coefficients  # Assuming `coefficients` holds the QUBO matrix\n\n    costs = []\n    for bitstring in self.bitstrings:\n        if isinstance(bitstring, str):\n            z = torch.tensor([int(b) for b in bitstring], dtype=torch.float32)\n        elif isinstance(bitstring, torch.Tensor):\n            z = bitstring.detach().clone()\n        else:\n            z = torch.tensor(bitstring, dtype=torch.float32)\n        cost = torch.matmul(\n            z.permute(*torch.arange(z.ndim - 1, -1, -1)), torch.matmul(QUBO, z)\n        ).item()  # Use the QUBO matrix from the instance\n        costs.append(cost)\n\n    return torch.tensor(costs)\n</code></pre>"},{"location":"api/data/#qubosolver.data.QUBOSolution.compute_probabilities","title":"<code>compute_probabilities()</code>","text":"<p>Computes the probabilities of each bitstring solution based on their counts.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>torch.Tensor: A tensor of probabilities for each bitstring.</p> Source code in <code>qubosolver/data.py</code> <pre><code>def compute_probabilities(self) -&gt; torch.Tensor:\n    \"\"\"\n    Computes the probabilities of each bitstring solution based on their counts.\n\n    Returns:\n        torch.Tensor: A tensor of probabilities for each bitstring.\n    \"\"\"\n    if self.counts is None:\n        raise ValueError(\"Counts are required to compute probabilities.\")\n\n    total_counts = self.counts.sum().item()\n    probabilities = (\n        self.counts / total_counts if total_counts &gt; 0 else torch.zeros_like(self.counts)\n    )\n    return probabilities\n</code></pre>"},{"location":"api/data/#qubosolver.data.QUBOSolution.sort_by_cost","title":"<code>sort_by_cost()</code>","text":"<p>Sorts the QUBOSolution in-place by increasing cost.</p> <p>Reorders bitstrings, costs, counts, and probabilities (if available) based on the ascending order of the costs.</p> Source code in <code>qubosolver/data.py</code> <pre><code>def sort_by_cost(self) -&gt; None:\n    \"\"\"\n    Sorts the QUBOSolution in-place by increasing cost.\n\n    Reorders bitstrings, costs, counts, and probabilities (if available)\n    based on the ascending order of the costs.\n    \"\"\"\n\n    sorted_indices = torch.argsort(self.costs)\n    self.bitstrings = self.bitstrings[sorted_indices]\n    self.costs = self.costs[sorted_indices]\n    if self.counts is not None:\n        self.counts = self.counts[sorted_indices]\n    if self.probabilities is not None:\n        self.probabilities = self.probabilities[sorted_indices]\n</code></pre>"},{"location":"api/data/#utility-functions","title":"Utility functions","text":""},{"location":"api/data/#qubosolver.data_utils.generate_symmetric_mask","title":"<code>generate_symmetric_mask(size, target, device, generator)</code>","text":"<p>Generate a symmetric boolean mask with an exact number of True elements     to match a certain density of QUBO.     Used in the <code>from_random</code> method of <code>QUBODataset</code>.</p> PARAMETER DESCRIPTION <code>size</code> <p>Size of problem.</p> <p> TYPE: <code>int</code> </p> <code>target</code> <p>Target number of elements.</p> <p> TYPE: <code>int</code> </p> <code>device</code> <p>Torch device.</p> <p> TYPE: <code>str</code> </p> <code>generator</code> <p>generator for randomness.</p> <p> TYPE: <code>Generator</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>torch.Tensor: Mask.</p> Source code in <code>qubosolver/data_utils.py</code> <pre><code>def generate_symmetric_mask(\n    size: int, target: int, device: str, generator: torch.Generator\n) -&gt; torch.Tensor:\n    \"\"\"Generate a symmetric boolean mask with an exact number of True elements\n        to match a certain density of QUBO.\n        Used in the `from_random` method of `QUBODataset`.\n\n    Args:\n        size (int): Size of problem.\n        target (int): Target number of elements.\n        device (str): Torch device.\n        generator (torch.Generator): generator for randomness.\n\n    Returns:\n        torch.Tensor: Mask.\n    \"\"\"\n    possible_x = []\n    for x in range(1, min(size, target) + 1):\n        if (target - x) % 2 == 0:\n            y = (target - x) // 2\n            if y &lt;= (size * (size - 1)) // 2:\n                possible_x.append(x)\n    if not possible_x:\n        x, y = 1, 0\n    else:\n        x = possible_x[\n            torch.randint(0, len(possible_x), (1,), device=device, generator=generator).item()\n        ]\n        y = (target - x) // 2\n\n    mask = torch.zeros((size, size), dtype=torch.bool, device=device)\n    diag_indices = torch.randperm(size, device=device, generator=generator)[:x]\n    for i in diag_indices.tolist():\n        mask[i, i] = True\n\n    upper_indices = torch.tensor(\n        [(i, j) for i in range(size) for j in range(i + 1, size)],\n        device=device,\n    )\n    if upper_indices.size(0) &gt; 0 and y &gt; 0:\n        perm = torch.randperm(upper_indices.size(0), device=device, generator=generator)[:y]\n        chosen_upper = upper_indices[perm]\n        for i, j in chosen_upper.tolist():\n            mask[i, j] = True\n            mask[j, i] = True\n    return mask\n</code></pre>"},{"location":"api/data/#qubosolver.saveload.load_qubo_dataset","title":"<code>load_qubo_dataset(filepath)</code>","text":"<p>Loads a QUBODataset from a file. Notes:     The file should contain data saved in the format used by <code>save_qubo_dataset</code>.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>Path to the file from which the QUBODataset will be loaded.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>QUBODataset</code> <p>The loaded QUBODataset object.</p> <p> TYPE: <code>QUBODataset</code> </p> Source code in <code>qubosolver/saveload.py</code> <pre><code>def load_qubo_dataset(filepath: str) -&gt; QUBODataset:\n    \"\"\"\n    Loads a QUBODataset from a file.\n    Notes:\n        The file should contain data saved in the format used by `save_qubo_dataset`.\n\n    Args:\n        filepath (str):\n            Path to the file from which the QUBODataset will be loaded.\n\n    Returns:\n        QUBODataset:\n            The loaded QUBODataset object.\n\n\n    \"\"\"\n    data = torch.load(filepath)\n    solutions = None\n    if data[\"solutions\"] is not None:\n        solutions = [\n            QUBOSolution(\n                bitstrings=solution[\"bitstrings\"],\n                counts=solution[\"counts\"],\n                probabilities=solution[\"probabilities\"],\n                costs=solution[\"costs\"],\n            )\n            for solution in data[\"solutions\"]\n        ]\n    return QUBODataset(coefficients=data[\"coefficients\"], solutions=solutions)\n</code></pre>"},{"location":"api/data/#qubosolver.saveload.load_qubo_instance","title":"<code>load_qubo_instance(filepath)</code>","text":"<p>Loads a QUBOInstance from a file.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>Path to the file from which the QUBOInstance will be loaded.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>QUBOInstance</code> <p>The loaded QUBOInstance object.</p> <p> TYPE: <code>QUBOInstance</code> </p> Notes <p>The file should contain data saved in the format used by <code>save_qubo_instance</code>.</p> Source code in <code>qubosolver/saveload.py</code> <pre><code>def load_qubo_instance(filepath: str) -&gt; QUBOInstance:\n    \"\"\"\n    Loads a QUBOInstance from a file.\n\n    Args:\n        filepath (str):\n            Path to the file from which the QUBOInstance will be loaded.\n\n    Returns:\n        QUBOInstance:\n            The loaded QUBOInstance object.\n\n    Notes:\n        The file should contain data saved in the format used by `save_qubo_instance`.\n    \"\"\"\n    data = torch.load(filepath, weights_only=False)\n    instance = QUBOInstance(\n        coefficients=data[\"coefficients\"],\n        device=data[\"device\"],\n        dtype=data[\"dtype\"],\n    )\n    instance.solution = data[\"solution\"]\n    return instance\n</code></pre>"},{"location":"api/data/#qubosolver.saveload.save_qubo_dataset","title":"<code>save_qubo_dataset(dataset, filepath)</code>","text":"<p>Saves a QUBODataset to a file.</p> PARAMETER DESCRIPTION <code>dataset</code> <p>The QUBODataset object to save.</p> <p> TYPE: <code>QUBODataset</code> </p> <code>filepath</code> <p>Path to the file where the QUBODataset will be saved.</p> <p> TYPE: <code>str</code> </p> Notes <p>The saved data includes:     - Coefficients (size x size x num_instances tensor)     - Solutions (optional, includes bitstrings, counts, probabilities, and costs)</p> Source code in <code>qubosolver/saveload.py</code> <pre><code>def save_qubo_dataset(dataset: QUBODataset, filepath: str) -&gt; None:\n    \"\"\"\n    Saves a QUBODataset to a file.\n\n    Args:\n        dataset (QUBODataset):\n            The QUBODataset object to save.\n        filepath (str):\n            Path to the file where the QUBODataset will be saved.\n\n    Notes:\n        The saved data includes:\n            - Coefficients (size x size x num_instances tensor)\n            - Solutions (optional, includes bitstrings, counts, probabilities, and costs)\n    \"\"\"\n    data = {\"coefficients\": dataset.coefficients, \"solutions\": None}\n    if dataset.solutions is not None:\n        data[\"solutions\"] = [\n            {\n                \"bitstrings\": solution.bitstrings,\n                \"counts\": solution.counts,\n                \"probabilities\": solution.probabilities,\n                \"costs\": solution.costs,\n            }\n            for solution in dataset.solutions\n        ]\n    torch.save(data, filepath)\n</code></pre>"},{"location":"api/data/#qubosolver.saveload.save_qubo_instance","title":"<code>save_qubo_instance(instance, filepath)</code>","text":"<p>Saves a QUBOInstance to a file.</p> PARAMETER DESCRIPTION <code>instance</code> <p>The QUBOInstance object to save.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>filepath</code> <p>Path to the file where the QUBOInstance will be saved.</p> <p> TYPE: <code>str</code> </p> Notes <p>The saved data includes:     - Coefficients (N x N matrix)     - Device (e.g., 'cpu' or 'cuda')     - Data type (e.g., torch.float32)     - Solution (optional)</p> Source code in <code>qubosolver/saveload.py</code> <pre><code>def save_qubo_instance(instance: QUBOInstance, filepath: str) -&gt; None:\n    \"\"\"\n    Saves a QUBOInstance to a file.\n\n    Args:\n        instance (QUBOInstance):\n            The QUBOInstance object to save.\n        filepath (str):\n            Path to the file where the QUBOInstance will be saved.\n\n    Notes:\n        The saved data includes:\n            - Coefficients (N x N matrix)\n            - Device (e.g., 'cpu' or 'cuda')\n            - Data type (e.g., torch.float32)\n            - Solution (optional)\n    \"\"\"\n    data = {\n        \"coefficients\": instance.coefficients,  # N x N\n        \"device\": instance.device,\n        \"dtype\": instance.dtype,\n        \"solution\": instance.solution,\n    }\n    torch.save(data, filepath)\n</code></pre>"},{"location":"api/quantum/","title":"Quantum-related components of a QUBO solver","text":""},{"location":"api/quantum/#pulse-shapping","title":"Pulse Shapping","text":""},{"location":"api/quantum/#qubosolver.pipeline.pulse.AdiabaticPulseShaper","title":"<code>AdiabaticPulseShaper(instance, config, backend)</code>","text":"<p>               Bases: <code>BasePulseShaper</code></p> <p>A Standard Adiabatic Pulse shaper.</p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig, backend: BaseBackend):\n    \"\"\"\n    Initialize the pulse shaping module with a QUBO instance.\n\n    Args:\n        instance (QUBOInstance): The QUBO problem instance.\n        config (SolverConfig): The solver configuration.\n        backend (BaseBackend): Backend to use.\n    \"\"\"\n    self.instance: QUBOInstance = instance\n    self.config: SolverConfig = config\n    self.pulse: Pulse | None = None\n    self.backend = backend\n    self.device = backend.device()\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.AdiabaticPulseShaper.generate","title":"<code>generate(register, instance)</code>","text":"<p>Generate an adiabatic pulse based on the QUBO instance and physical register.</p> PARAMETER DESCRIPTION <code>register</code> <p>The physical register layout for the quantum system.</p> <p> TYPE: <code>Register</code> </p> <code>instance</code> <p>The QUBO instance.</p> <p> TYPE: <code>QUBOInstance</code> </p> RETURNS DESCRIPTION <code>tuple[Pulse, QUBOSolution]</code> <p>tuple[Pulse, QUBOSolution | None]: - Pulse: A generated pulse object wrapping a Pulser pulse. - QUBOSolution: An instance of the qubo solution     - str | None: The bitstring (solution) -&gt; Not computed     - float | None: The cost (energy value) -&gt; Not computed     - float | None: The probabilities for each bitstring -&gt; Not computed     - float | None: The counts of each bitstring -&gt; Not computed</p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def generate(\n    self,\n    register: Register,\n    instance: QUBOInstance,\n) -&gt; tuple[Pulse, QUBOSolution]:\n    \"\"\"\n    Generate an adiabatic pulse based on the QUBO instance and physical register.\n\n    Args:\n        register (Register): The physical register layout for the quantum system.\n        instance (QUBOInstance): The QUBO instance.\n\n    Returns:\n        tuple[Pulse, QUBOSolution | None]:\n            - Pulse: A generated pulse object wrapping a Pulser pulse.\n            - QUBOSolution: An instance of the qubo solution\n                - str | None: The bitstring (solution) -&gt; Not computed\n                - float | None: The cost (energy value) -&gt; Not computed\n                - float | None: The probabilities for each bitstring -&gt; Not computed\n                - float | None: The counts of each bitstring -&gt; Not computed\n    \"\"\"\n\n    QUBO = instance.coefficients\n    weights_list = torch.abs(torch.diag(QUBO)).tolist()\n    max_node_weight = max(weights_list)\n    norm_weights_list = [1 - (w / max_node_weight) for w in weights_list]\n\n    T = 4000\n    off_diag = QUBO[\n        ~torch.eye(QUBO.shape[0], dtype=bool)\n    ]  # Selecting off-diagonal terms of the Qubo with a mask\n    rydberg_global = self.device.channels[\"rydberg_global\"]\n    assert rydberg_global.max_amp is not None  # FIXME: Document why\n    Omega = min(\n        torch.max(off_diag).item(),\n        rydberg_global.max_amp - 1e-9,\n    )\n\n    delta_0 = torch.min(torch.diag(QUBO)).item()\n    delta_f = -delta_0\n\n    amp_wave = InterpolatedWaveform(T, [1e-9, Omega, 1e-9])\n    det_wave = InterpolatedWaveform(T, [delta_0, 0, delta_f])\n\n    pulser_pulse = PulserPulse(amp_wave, det_wave, 0)\n    # PulserPulse has some magic that ensures its constructor does not always return\n    # an instance of PulserPulse. Let's make sure (and help mypy realize) that we\n    # are building an instance of PulserPulse.\n    assert isinstance(pulser_pulse, PulserPulse)\n\n    shaped_pulse = Pulse(pulse=pulser_pulse)\n    shaped_pulse.norm_weights = norm_weights_list\n    shaped_pulse.duration = T\n\n    self.pulse = shaped_pulse\n    solution = QUBOSolution(torch.Tensor(), torch.Tensor())\n\n    return self.pulse, solution\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.BasePulseShaper","title":"<code>BasePulseShaper(instance, config, backend)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for generating pulse schedules based on a QUBO problem.</p> <p>This class transforms the structure of a QUBOInstance into a quantum pulse sequence that can be applied to a physical register. The register is passed at the time of pulse generation, not during initialization.</p> ATTRIBUTE DESCRIPTION <code>instance</code> <p>The QUBO problem instance.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>config</code> <p>The solver configuration.</p> <p> TYPE: <code>SolverConfig</code> </p> <code>pulse</code> <p>A saved current pulse obtained by <code>generate</code>.</p> <p> TYPE: <code>Pulse</code> </p> <code>backend</code> <p>Backend to use.</p> <p> TYPE: <code>BaseBackend</code> </p> <code>device</code> <p>Device from backend.</p> <p> TYPE: <code>Device</code> </p> <p>Initialize the pulse shaping module with a QUBO instance.</p> PARAMETER DESCRIPTION <code>instance</code> <p>The QUBO problem instance.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>config</code> <p>The solver configuration.</p> <p> TYPE: <code>SolverConfig</code> </p> <code>backend</code> <p>Backend to use.</p> <p> TYPE: <code>BaseBackend</code> </p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig, backend: BaseBackend):\n    \"\"\"\n    Initialize the pulse shaping module with a QUBO instance.\n\n    Args:\n        instance (QUBOInstance): The QUBO problem instance.\n        config (SolverConfig): The solver configuration.\n        backend (BaseBackend): Backend to use.\n    \"\"\"\n    self.instance: QUBOInstance = instance\n    self.config: SolverConfig = config\n    self.pulse: Pulse | None = None\n    self.backend = backend\n    self.device = backend.device()\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.BasePulseShaper.generate","title":"<code>generate(register, instance)</code>  <code>abstractmethod</code>","text":"<p>Generate a pulse based on the problem and the provided register.</p> PARAMETER DESCRIPTION <code>register</code> <p>The physical register layout.</p> <p> TYPE: <code>Register</code> </p> <code>instance</code> <p>The QUBO instance.</p> <p> TYPE: <code>QUBOInstance</code> </p> RETURNS DESCRIPTION <code>Pulse</code> <p>A generated pulse object wrapping a Pulser pulse.</p> <p> TYPE: <code>Pulse</code> </p> <code>QUBOSolution</code> <p>An instance of the qubo solution</p> <p> TYPE: <code>QUBOSolution</code> </p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>@abstractmethod\ndef generate(\n    self,\n    register: Register,\n    instance: QUBOInstance,\n) -&gt; tuple[Pulse, QUBOSolution]:\n    \"\"\"\n    Generate a pulse based on the problem and the provided register.\n\n    Args:\n        register (Register): The physical register layout.\n        instance (QUBOInstance): The QUBO instance.\n\n    Returns:\n        Pulse: A generated pulse object wrapping a Pulser pulse.\n        QUBOSolution: An instance of the qubo solution\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.OptimizedPulseShaper","title":"<code>OptimizedPulseShaper(instance, config, backend)</code>","text":"<p>               Bases: <code>BasePulseShaper</code></p> <p>Pulse shaper that uses optimization to find the best pulse parameters for solving QUBOs. Returns an optimized pulse, the bitstrings, their counts, probabilities, and costs.</p> ATTRIBUTE DESCRIPTION <code>pulse</code> <p>current pulse.</p> <p> TYPE: <code>Pulse</code> </p> <code>best_cost</code> <p>Current best cost.</p> <p> TYPE: <code>float</code> </p> <code>best_bitstring</code> <p>Current best bitstring.</p> <p> TYPE: <code>Tensor | list</code> </p> <code>bitstrings</code> <p>List of current bitstrings obtained.</p> <p> TYPE: <code>Tensor | list</code> </p> <code>counts</code> <p>Frequencies of bitstrings.</p> <p> TYPE: <code>Tensor | list</code> </p> <code>probabilities</code> <p>Probabilities of bitstrings.</p> <p> TYPE: <code>Tensor | list</code> </p> <code>costs</code> <p>Qubo cost.</p> <p> TYPE: <code>Tensor | list</code> </p> <code>custom_qubo_cost</code> <p>Apply a different qubo cost evaluation during optimization. Must be defined as: <code>def custom_qubo_cost(bitstring: str, QUBO: torch.Tensor) -&gt; float</code>. Defaults to None, meaning we use the default QUBO evaluation.</p> <p> TYPE: <code>Callable[[str, Tensor], float]</code> </p> <code>custom_objective_fn</code> <p>For bayesian optimization, one can change the output of <code>self.run_simulation</code> to optimize differently. Instead of using the best cost out of the samples, one can change the objective for an average, or any function out of the form <code>cost_eval = custom_objective_fn(bitstrings,     counts, probabilities, costs, best_cost, best_bitstring)</code> Defaults to None, which means we optimize using the best cost out of the samples.</p> <p> TYPE: <code>Callable[[list, list, list, list, float, str], float]</code> </p> <code>callback_objective</code> <p>Apply a callback during bayesian optimization. Only accepts one input dictionary created during optimization <code>d = {\"x\": x, \"cost_eval\": cost_eval}</code> hence should be defined as: <code>def callback_fn(d: dict) -&gt; None:</code> Defaults to None, which means no callback is applied.</p> <p> TYPE: <code>Callable[..., None]</code> </p> <p>Instantiate an <code>OptimizedPulseShaper</code>.</p> PARAMETER DESCRIPTION <code>instance</code> <p>Qubo instance.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>config</code> <p>Configuration for solving.</p> <p> TYPE: <code>SolverConfig</code> </p> <code>backend</code> <p>Backend to use during optimization.</p> <p> TYPE: <code>BaseBackend</code> </p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def __init__(\n    self,\n    instance: QUBOInstance,\n    config: SolverConfig,\n    backend: BaseBackend,\n):\n    \"\"\"Instantiate an `OptimizedPulseShaper`.\n\n    Args:\n        instance (QUBOInstance): Qubo instance.\n        config (SolverConfig): Configuration for solving.\n        backend (BaseBackend): Backend to use during optimization.\n\n    \"\"\"\n    super().__init__(instance, config, backend)\n\n    self.pulse = None\n    self.best_cost = None\n    self.best_bitstring = None\n    self.best_params = None\n    self.bitstrings = None\n    self.counts = None\n    self.probabilities = None\n    self.costs = None\n    self.custom_qubo_cost = self.config.pulse_shaping.custom_qubo_cost\n    self.custom_objective_fn = self.config.pulse_shaping.custom_objective\n    self.callback_objective = self.config.pulse_shaping.callback_objective\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.OptimizedPulseShaper.build_pulse","title":"<code>build_pulse(params)</code>","text":"<p>Build the pulse from a list of parameters for the objective.</p> PARAMETER DESCRIPTION <code>params</code> <p>List of parameters.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>Pulse</code> <p>pulse sequence.</p> <p> TYPE: <code>Pulse</code> </p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def build_pulse(self, params: list) -&gt; Pulse:\n    \"\"\"Build the pulse from a list of parameters for the objective.\n\n    Args:\n        params (list): List of parameters.\n\n    Returns:\n        Pulse: pulse sequence.\n    \"\"\"\n    amp = InterpolatedWaveform(5000, [1e-9] + list(params[:3]) + [1e-9])\n    det = InterpolatedWaveform(5000, [params[3]] + list(params[4:]) + [params[3]])\n    pulser_pulse = PulserPulse(amp, det, 0)\n    # PulserPulse has some magic that ensures its constructor does not always return\n    # an instance of PulserPulse. Let's make sure (and help mypy realize) that we\n    # are building an instance of PulserPulse.\n    assert isinstance(pulser_pulse, PulserPulse)\n\n    pulse = Pulse(\n        pulse=pulser_pulse,\n        norm_weights=self.norm_weights_list,\n        duration=5000,\n    )\n    # pulse.pulse.norm_weights = self.norm_weights_list\n    # pulse.pulse.duration = 5000\n    return pulse\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.OptimizedPulseShaper.compute_qubo_cost","title":"<code>compute_qubo_cost(bitstring, QUBO)</code>","text":"<p>The qubo cost for a single bitstring to apply during optimization.</p> PARAMETER DESCRIPTION <code>bitstring</code> <p>candidate bitstring.</p> <p> TYPE: <code>str</code> </p> <code>QUBO</code> <p>qubo coefficients.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>float</code> <p>respective cost of bitstring.</p> <p> TYPE: <code>float</code> </p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def compute_qubo_cost(self, bitstring: str, QUBO: torch.Tensor) -&gt; float:\n    \"\"\"The qubo cost for a single bitstring to apply during optimization.\n\n    Args:\n        bitstring (str): candidate bitstring.\n        QUBO (torch.Tensor): qubo coefficients.\n\n    Returns:\n        float: respective cost of bitstring.\n    \"\"\"\n    if self.custom_qubo_cost is None:\n        return calculate_qubo_cost(bitstring, QUBO)\n\n    return cast(float, self.custom_qubo_cost(bitstring, QUBO))\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.OptimizedPulseShaper.generate","title":"<code>generate(register, instance)</code>","text":"<p>Generate a pulse via optimization.</p> PARAMETER DESCRIPTION <code>register</code> <p>The physical register layout.</p> <p> TYPE: <code>Register</code> </p> <code>instance</code> <p>The QUBO instance.</p> <p> TYPE: <code>QUBOInstance</code> </p> RETURNS DESCRIPTION <code>Pulse</code> <p>A generated pulse object wrapping a Pulser pulse.</p> <p> TYPE: <code>Pulse</code> </p> <code>QUBOSolution</code> <p>An instance of the qubo solution</p> <p> TYPE: <code>QUBOSolution</code> </p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def generate(\n    self,\n    register: Register,\n    instance: QUBOInstance,\n) -&gt; tuple[Pulse, QUBOSolution]:\n    \"\"\"\n    Generate a pulse via optimization.\n\n    Args:\n        register (Register): The physical register layout.\n        instance (QUBOInstance): The QUBO instance.\n\n    Returns:\n        Pulse: A generated pulse object wrapping a Pulser pulse.\n        QUBOSolution: An instance of the qubo solution\n    \"\"\"\n    # TODO: Harmonize the output of the pulse_shaper generate\n    QUBO = instance.coefficients\n    self.register = register\n    self.norm_weights_list = self._compute_norm_weights(QUBO)\n\n    n_amp = 3\n    n_det = 3\n    max_amp = self.device.channels[\"rydberg_global\"].max_amp\n    assert max_amp is not None\n    max_amp = max_amp - 1e-6\n    # added to avoid rouding errors that make the simulation fail (overcoming max_amp)\n\n    max_det = self.device.channels[\"rydberg_global\"].max_abs_detuning\n    assert max_det is not None\n    max_det -= 1e-6\n    # same\n\n    bounds = [(1, max_amp)] * n_amp + [(-max_det, 0)] + [(-max_det, max_det)] * (n_det - 1)\n    x0 = (\n        self.config.pulse_shaping.initial_omega_parameters\n        + self.config.pulse_shaping.initial_detuning_parameters\n    )\n\n    def objective(x: list[float]) -&gt; float:\n        pulse = self.build_pulse(x)\n\n        try:\n            bitstrings, counts, probabilities, costs, cost_eval, best_bitstring = (\n                self.run_simulation(\n                    self.register,\n                    pulse,\n                    QUBO,\n                    convert_to_tensor=False,\n                )\n            )\n            if self.custom_objective_fn is not None:\n                cost_eval = self.custom_objective_fn(\n                    bitstrings,\n                    counts,\n                    probabilities,\n                    costs,\n                    cost_eval,\n                    best_bitstring,\n                )\n            if not np.isfinite(cost_eval):\n                print(f\"[Warning] Non-finite cost encountered: {cost_eval} at x={x}\")\n                cost_eval = 1e4\n\n        except Exception as e:\n            print(f\"[Exception] Error during simulation at x={x}: {e}\")\n            cost_eval = 1e4\n\n        if self.callback_objective is not None:\n            self.callback_objective({\"x\": x, \"cost_eval\": cost_eval})\n        return float(cost_eval)\n\n    opt_result = gp_minimize(objective, bounds, x0=x0, n_calls=self.config.n_calls)\n\n    if opt_result and opt_result.x:\n        self.best_params = opt_result.x\n        self.pulse = self.build_pulse(self.best_params)  # type: ignore[arg-type]\n\n        (\n            self.bitstrings,\n            self.counts,\n            self.probabilities,\n            self.costs,\n            self.best_cost,\n            self.best_bitstring,\n        ) = self.run_simulation(self.register, self.pulse, QUBO, convert_to_tensor=True)\n\n    if self.bitstrings is None or self.counts is None:\n        # TODO: what needs to be returned here?\n        # the generate function should always return a pulse - even if it is not good.\n        # we need to return a pulse (self.pulse) - which is none here.\n        return self.pulse, QUBOSolution(None, None)  # type: ignore[return-value]\n\n    assert self.costs is not None\n    solution = QUBOSolution(\n        bitstrings=self.bitstrings,\n        counts=self.counts,\n        probabilities=self.probabilities,\n        costs=self.costs,\n    )\n    assert self.pulse is not None\n    return self.pulse, solution\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.OptimizedPulseShaper.run_simulation","title":"<code>run_simulation(register, pulse, QUBO, convert_to_tensor=True)</code>","text":"<p>Run a quantum program using backend and returns     a tuple of (bitstrings, counts, probabilities, costs, best cost, best bitstring).</p> PARAMETER DESCRIPTION <code>register</code> <p>register of quantum program.</p> <p> TYPE: <code>Register</code> </p> <code>pulse</code> <p>pulse sequence to run on backend.</p> <p> TYPE: <code>Pulse</code> </p> <code>QUBO</code> <p>Qubo coefficients.</p> <p> TYPE: <code>Tensor</code> </p> <code>convert_to_tensor</code> <p>Convert tuple components to tensors. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple of (bitstrings, counts, probabilities, costs, best cost, best bitstring)</p> <p> TYPE: <code>tuple</code> </p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def run_simulation(\n    self,\n    register: Register,\n    pulse: Pulse,\n    QUBO: torch.Tensor,\n    convert_to_tensor: bool = True,\n) -&gt; tuple:\n    \"\"\"Run a quantum program using backend and returns\n        a tuple of (bitstrings, counts, probabilities, costs, best cost, best bitstring).\n\n    Args:\n        register (Register): register of quantum program.\n        pulse (Pulse): pulse sequence to run on backend.\n        QUBO (torch.Tensor): Qubo coefficients.\n        convert_to_tensor (bool, optional): Convert tuple components to tensors.\n            Defaults to True.\n\n    Returns:\n        tuple: tuple of (bitstrings, counts, probabilities, costs, best cost, best bitstring)\n    \"\"\"\n    try:\n        program = QuantumProgram(\n            register=register.register, pulse=pulse.pulse, device=self.device\n        )\n        bitstring_counts = self.backend.run(program).counts\n\n        cost_dict = {b: self.compute_qubo_cost(b, QUBO) for b in bitstring_counts.keys()}\n\n        best_bitstring = min(cost_dict, key=cost_dict.get)  # type: ignore[arg-type]\n        best_cost = cost_dict[best_bitstring]\n\n        if convert_to_tensor:\n            keys = list(bitstring_counts.keys())\n            values = list(bitstring_counts.values())\n\n            bitstrings_tensor = torch.tensor(\n                [[int(b) for b in bitstr] for bitstr in keys], dtype=torch.int32\n            )\n            counts_tensor = torch.tensor(values, dtype=torch.int32)\n            probabilities_tensor = counts_tensor.float() / counts_tensor.sum()\n\n            costs_tensor = torch.tensor(\n                [self.compute_qubo_cost(b, QUBO) for b in keys], dtype=torch.float32\n            )\n\n            return (\n                bitstrings_tensor,\n                counts_tensor,\n                probabilities_tensor,\n                costs_tensor,\n                best_cost,\n                best_bitstring,\n            )\n        else:\n            counts = list(bitstring_counts.values())\n            nsamples = float(sum(counts))\n            return (\n                list(bitstring_counts.keys()),\n                counts,\n                [c / nsamples for c in counts],\n                list(cost_dict.values()),\n                best_cost,\n                best_bitstring,\n            )\n\n    except Exception as e:\n        print(f\"Simulation failed: {e}\")\n        return (\n            torch.tensor([]),\n            torch.tensor([]),\n            torch.tensor([]),\n            torch.tensor([]),\n            float(\"inf\"),\n            None,\n        )\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.pulse.get_pulse_shaper","title":"<code>get_pulse_shaper(instance, config, backend)</code>","text":"<p>Method that returns the correct PulseShaper based on configuration. The correct pulse shaping method can be identified using the config, and an object of this pulseshaper can be returned using this function.</p> PARAMETER DESCRIPTION <code>instance</code> <p>The QUBO problem to embed.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>config</code> <p>The solver configuration used.</p> <p> TYPE: <code>SolverConfig</code> </p> <code>backend</code> <p>Backend to extract device from or to use during pulse shaping.</p> <p> TYPE: <code>BaseBackend</code> </p> RETURNS DESCRIPTION <code>BasePulseShaper</code> <p>The representative Pulse Shaper object.</p> Source code in <code>qubosolver/pipeline/pulse.py</code> <pre><code>def get_pulse_shaper(\n    instance: QUBOInstance,\n    config: SolverConfig,\n    backend: BaseBackend,\n) -&gt; BasePulseShaper:\n    \"\"\"\n    Method that returns the correct PulseShaper based on configuration.\n    The correct pulse shaping method can be identified using the config, and an\n    object of this pulseshaper can be returned using this function.\n\n    Args:\n        instance (QUBOInstance): The QUBO problem to embed.\n        config (SolverConfig): The solver configuration used.\n        backend (BaseBackend): Backend to extract device from or to use\n            during pulse shaping.\n\n    Returns:\n        (BasePulseShaper): The representative Pulse Shaper object.\n    \"\"\"\n    if config.pulse_shaping.pulse_shaping_method == PulseType.ADIABATIC:\n        return AdiabaticPulseShaper(instance, config, backend)\n    elif config.pulse_shaping.pulse_shaping_method == PulseType.OPTIMIZED:\n        return OptimizedPulseShaper(instance, config, backend)\n    elif issubclass(config.pulse_shaping.pulse_shaping_method, BasePulseShaper):\n        return cast(\n            BasePulseShaper,\n            config.pulse_shaping.pulse_shaping_method(instance, config, backend),\n        )\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/quantum/#embedding","title":"Embedding","text":""},{"location":"api/quantum/#qubosolver.pipeline.embedder.BLaDEmbedder","title":"<code>BLaDEmbedder(instance, config, backend)</code>","text":"<p>               Bases: <code>BaseEmbedder</code></p> <p>BLaDE (Balanced Latently Dimensional Embedder)</p> <p>Computes positions for nodes so that their interactions according to a device approach the desired values at best. The result can be used as an embedding. Its prior target is on interaction matrices or QUBOs, but it can also be used for MIS with limitations if the adjacency matrix is converted into a QUBO. The general principle is based on the Fruchterman-Reingold algorithm.</p> Source code in <code>qubosolver/pipeline/embedder.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig, backend: BaseBackend):\n    \"\"\"\n    Args:\n        instance (QUBOInstance): The QUBO problem to embed.\n        config (SolverConfig): The Solver Configuration.\n    \"\"\"\n    self.instance: QUBOInstance = instance\n    self.config: SolverConfig = config\n    self.register: TargetRegister | None = None\n    self.backend = backend\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.embedder.BaseEmbedder","title":"<code>BaseEmbedder(instance, config, backend)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all embedders.</p> <p>Prepares the geometry (register) of atoms based on the QUBO instance. Returns a Register compatible with Pasqal/Pulser devices.</p> PARAMETER DESCRIPTION <code>instance</code> <p>The QUBO problem to embed.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>config</code> <p>The Solver Configuration.</p> <p> TYPE: <code>SolverConfig</code> </p> Source code in <code>qubosolver/pipeline/embedder.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig, backend: BaseBackend):\n    \"\"\"\n    Args:\n        instance (QUBOInstance): The QUBO problem to embed.\n        config (SolverConfig): The Solver Configuration.\n    \"\"\"\n    self.instance: QUBOInstance = instance\n    self.config: SolverConfig = config\n    self.register: TargetRegister | None = None\n    self.backend = backend\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.embedder.BaseEmbedder.embed","title":"<code>embed()</code>  <code>abstractmethod</code>","text":"<p>Creates a layout of atoms as the register.</p> RETURNS DESCRIPTION <code>Register</code> <p>The register.</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qubosolver/pipeline/embedder.py</code> <pre><code>@abstractmethod\ndef embed(self) -&gt; TargetRegister:\n    \"\"\"\n    Creates a layout of atoms as the register.\n\n    Returns:\n        Register: The register.\n    \"\"\"\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.embedder.GreedyEmbedder","title":"<code>GreedyEmbedder(instance, config, backend)</code>","text":"<p>               Bases: <code>BaseEmbedder</code></p> <p>Create an embedding in a greedy fashion.</p> <p>At each step, place one logical node onto one trap to minimize the incremental mismatch between the logical QUBO matrix Q and the physical interaction matrix U (approx. C / ||r_i - r_j||^6).</p> Source code in <code>qubosolver/pipeline/embedder.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig, backend: BaseBackend):\n    \"\"\"\n    Args:\n        instance (QUBOInstance): The QUBO problem to embed.\n        config (SolverConfig): The Solver Configuration.\n    \"\"\"\n    self.instance: QUBOInstance = instance\n    self.config: SolverConfig = config\n    self.register: TargetRegister | None = None\n    self.backend = backend\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.embedder.GreedyEmbedder.embed","title":"<code>embed()</code>","text":"<p>Creates a layout of atoms as the register.</p> RETURNS DESCRIPTION <code>Register</code> <p>The register.</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qubosolver/pipeline/embedder.py</code> <pre><code>@typing.no_type_check\ndef embed(self) -&gt; TargetRegister:\n    \"\"\"\n    Creates a layout of atoms as the register.\n\n    Returns:\n        Register: The register.\n    \"\"\"\n    if self.config.embedding.traps &lt; self.instance.size:\n        raise ValueError(\n            \"Number of traps must be at least equal to the number of atoms on the register.\"\n        )\n\n    # compute density (unchanged)\n    self.config.embedding.density = calculate_density(\n        self.instance.coefficients, self.instance.size\n    )\n\n    # build params for the Greedy algorithm\n    params = {\n        \"device\": self.backend.device(),\n        \"layout\": self.config.embedding.layout_greedy_embedder,\n        \"traps\": int(self.config.embedding.traps),\n        \"spacing\": float(self.config.embedding.spacing),\n        # animation controls (all read by Greedy)\n        \"draw_steps\": bool(self.config.embedding.draw_steps),  # collect per-step data\n        \"animation\": bool(self.config.embedding.draw_steps),  # render animation after run\n        \"animation_save_path\": self.config.embedding.animation_save_path,  # optional export\n        # \"animation_top_k\": 5,  # (optional) uncomment if you add support for this in Greedy\n    }\n\n    # --- DEBUG / INFO: show where Greedy comes from + the params we\u2019ll pass\n    dev = params[\"device\"]\n    dev_str = (\n        getattr(dev, \"name\", None)\n        or getattr(dev, \"device_name\", None)\n        or dev.__class__.__name__\n    )\n    printable = dict(params)\n    printable[\"device\"] = dev_str  # avoid dumping the whole object\n    # --- Call Greedy (unchanged public signature)\n    best, _, coords, _, _ = Greedy().launch_greedy(\n        Q=self.instance.coefficients,\n        params=params,\n        # no extra kwargs; Greedy reads animation/draw/save_path from params\n    )\n\n    # build the register (unchanged)\n    qubits = {f\"q{i}\": coord for i, coord in enumerate(coords)}\n    register = PulserRegister(qubits)\n    return TargetRegister(self.backend.device(), register)\n</code></pre>"},{"location":"api/quantum/#qubosolver.pipeline.embedder.get_embedder","title":"<code>get_embedder(instance, config, backend)</code>","text":"<p>Method that returns the correct embedder based on configuration. The correct embedding method can be identified using the config, and an object of this embedding can be returned using this function.</p> PARAMETER DESCRIPTION <code>instance</code> <p>The QUBO problem to embed.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>config</code> <p>The quantum device to target.</p> <p> TYPE: <code>Device</code> </p> RETURNS DESCRIPTION <code>BaseEmbedder</code> <p>The representative embedder object.</p> Source code in <code>qubosolver/pipeline/embedder.py</code> <pre><code>def get_embedder(\n    instance: QUBOInstance, config: SolverConfig, backend: BaseBackend\n) -&gt; BaseEmbedder:\n    \"\"\"\n    Method that returns the correct embedder based on configuration.\n    The correct embedding method can be identified using the config, and an\n    object of this embedding can be returned using this function.\n\n    Args:\n        instance (QUBOInstance): The QUBO problem to embed.\n        config (Device): The quantum device to target.\n\n    Returns:\n        (BaseEmbedder): The representative embedder object.\n    \"\"\"\n\n    if config.embedding.embedding_method == EmbedderType.BLADE:\n        return BLaDEmbedder(instance, config, backend)\n    elif config.embedding.embedding_method == EmbedderType.GREEDY:\n        return GreedyEmbedder(instance, config, backend)\n    elif issubclass(config.embedding.embedding_method, BaseEmbedder):\n        return typing.cast(\n            BaseEmbedder, config.embedding.embedding_method(instance, config, backend)\n        )\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/qubo_instance/","title":"QUBOInstance","text":""},{"location":"api/qubo_instance/#qubosolver.qubo_instance.QUBOInstance","title":"<code>QUBOInstance(coefficients=None, device='cpu', dtype=torch.float32)</code>","text":"<p>Represents a single instance of a Quadratic Unconstrained Binary Optimization (QUBO) problem.</p> ATTRIBUTE DESCRIPTION <code>coefficients</code> <p>Tensor of shape (size, size), representing the QUBO coefficients.</p> <p> TYPE: <code>Tensor</code> </p> <code>device</code> <p>Device where tensors are allocated (e.g., \"cpu\" or \"cuda\").</p> <p> TYPE: <code>str</code> </p> <code>dtype</code> <p>Data type of the tensors (e.g., torch.float32).</p> <p> TYPE: <code>dtype</code> </p> <code>size</code> <p>Size of the QUBO matrix (number of variables).</p> <p> TYPE: <code>int | None</code> </p> <code>solution</code> <p>Solution to the QUBO problem, if available.</p> <p> TYPE: <code>QUBOSolution | None</code> </p> <code>density</code> <p>Fraction of non-zero entries in the coefficient matrix.</p> <p> TYPE: <code>float | None</code> </p> <code>density_type</code> <p>Classification of the density (e.g., sparse, dense).</p> <p> TYPE: <code>DensityType | None</code> </p> <p>Initializes a QUBOInstance.</p> PARAMETER DESCRIPTION <code>coefficients</code> <p>Coefficients of the QUBO problem. Can be a dictionary, array-like object, or None.</p> <p> TYPE: <code>dict | ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>device</code> <p>Device where tensors are allocated (default: \"cpu\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>dtype</code> <p>Data type of the tensors (default: torch.float32).</p> <p> TYPE: <code>dtype</code> DEFAULT: <code>float32</code> </p> Source code in <code>qubosolver/qubo_instance.py</code> <pre><code>def __init__(\n    self,\n    coefficients: dict | ArrayLike | None = None,\n    device: str = \"cpu\",\n    dtype: torch.dtype = torch.float32,\n):\n    \"\"\"\n    Initializes a QUBOInstance.\n\n    Args:\n        coefficients (dict | ArrayLike | None):\n            Coefficients of the QUBO problem. Can be a dictionary, array-like object, or None.\n        device (str):\n            Device where tensors are allocated (default: \"cpu\").\n        dtype (torch.dtype):\n            Data type of the tensors (default: torch.float32).\n    \"\"\"\n    self.device = device\n    self.dtype = dtype\n    self.size: int | None\n    self._coefficients: torch.Tensor | None = None\n    self.solution: QUBOSolution | None = None\n    self.density: float | None = None\n    self.density_type: DensityType | None = None\n\n    if coefficients is not None:\n        self.coefficients = coefficients\n</code></pre>"},{"location":"api/qubo_instance/#qubosolver.qubo_instance.QUBOInstance.coefficients","title":"<code>coefficients</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for the QUBO coefficient matrix.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>torch.Tensor: Tensor of shape (size, size) representing the QUBO coefficients.</p>"},{"location":"api/qubo_instance/#qubosolver.qubo_instance.QUBOInstance.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the QUBOInstance.</p> RETURNS DESCRIPTION <code>str</code> <p>A dictionary-like string summarizing the instance.</p> <p> TYPE: <code>str</code> </p> Source code in <code>qubosolver/qubo_instance.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the QUBOInstance.\n\n    Returns:\n        str: A dictionary-like string summarizing the instance.\n    \"\"\"\n    return repr(\n        f\"QUBOInstance of size = {self.size},\"\n        f\"density = {round(self.density, 2) if self.density else None},\"\n    )\n</code></pre>"},{"location":"api/qubo_instance/#qubosolver.qubo_instance.QUBOInstance.evaluate_solution","title":"<code>evaluate_solution(solution)</code>","text":"<p>Evaluates a solution for the QUBO problem.</p> PARAMETER DESCRIPTION <code>solution</code> <p>Solution vector to evaluate.</p> <p> TYPE: <code>list | tuple | ArrayLike</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The cost of the given solution.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the solution size does not match the QUBO size.</p> Source code in <code>qubosolver/qubo_instance.py</code> <pre><code>def evaluate_solution(self, solution: list | tuple | ArrayLike) -&gt; float:\n    \"\"\"\n    Evaluates a solution for the QUBO problem.\n\n    Args:\n        solution (list | tuple | ArrayLike):\n            Solution vector to evaluate.\n\n    Returns:\n        float:\n            The cost of the given solution.\n\n    Raises:\n        ValueError: If the solution size does not match the QUBO size.\n    \"\"\"\n    solution_tensor = convert_to_tensor(solution, device=self.device, dtype=self.dtype)\n    if self._coefficients is None or solution_tensor.size(0) != self.size:\n        raise ValueError(\"Solution size does not match the QUBO problem size.\")\n    cost = torch.matmul(\n        solution_tensor, torch.matmul(self._coefficients, solution_tensor)\n    ).item()\n    solution = solution_tensor\n    return float(cost)\n</code></pre>"},{"location":"api/qubo_instance/#qubosolver.qubo_instance.QUBOInstance.set_coefficients","title":"<code>set_coefficients(new_coefficients=None)</code>","text":"<p>Updates the coefficients of the QUBO problem.</p> PARAMETER DESCRIPTION <code>new_coefficients</code> <p>Dictionary of new coefficients to set. Keys are (row, column) tuples.</p> <p> TYPE: <code>dict[tuple[int, int], float] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qubosolver/qubo_instance.py</code> <pre><code>def set_coefficients(\n    self, new_coefficients: dict[tuple[int, int], float] | None = None\n) -&gt; None:\n    \"\"\"\n    Updates the coefficients of the QUBO problem.\n\n    Args:\n        new_coefficients (dict[tuple[int, int], float] | None):\n            Dictionary of new coefficients to set. Keys are (row, column) tuples.\n    \"\"\"\n    if not new_coefficients:\n        return\n\n    max_index = max(max(i, j) for i, j in new_coefficients.keys())\n    if self.size and max_index &gt;= self.size:\n        self._expand_size(max_index + 1)\n\n    indices = torch.tensor(list(new_coefficients.keys()), dtype=torch.long, device=self.device)\n    values = torch.tensor(list(new_coefficients.values()), dtype=self.dtype, device=self.device)\n    self._coefficients[indices[:, 0], indices[:, 1]] = values  # type: ignore[index]\n    off_diagonal_mask = indices[:, 0] != indices[:, 1]\n    symmetric_indices = indices[off_diagonal_mask]\n    self._coefficients[symmetric_indices[:, 1], symmetric_indices[:, 0]] = values[  # type: ignore[index]\n        off_diagonal_mask\n    ]\n\n    self.update_metrics()\n</code></pre>"},{"location":"api/qubo_instance/#qubosolver.qubo_instance.QUBOInstance.update_metrics","title":"<code>update_metrics()</code>","text":"<p>Updates the density metrics of the QUBO problem.</p> Source code in <code>qubosolver/qubo_instance.py</code> <pre><code>def update_metrics(self) -&gt; None:\n    \"\"\"\n    Updates the density metrics of the QUBO problem.\n    \"\"\"\n    if self._coefficients is not None:\n        self.density = calculate_density(self._coefficients, self.size)\n        self.density_type = classify_density(self.density)\n    else:\n        self.density = self.density_type = None\n</code></pre>"},{"location":"api/solver/","title":"Solvers","text":""},{"location":"api/solver/#qubosolver.solver.QuboSolver","title":"<code>QuboSolver(instance, config=None)</code>","text":"<p>               Bases: <code>BaseSolver</code></p> <p>Dispatcher that selects the appropriate solver (quantum or classical) based on the SolverConfig and delegates execution to it.</p> Source code in <code>qubosolver/solver.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig | None = None):\n    super().__init__(instance, config)\n    self._solver: BaseSolver\n\n    if config is None:\n        self._solver = QuboSolverClassical(instance, self.config)\n    else:\n        if config.use_quantum:\n            self._solver = QuboSolverQuantum(instance, config)\n        else:\n            self._solver = QuboSolverClassical(instance, config)\n\n    self.n_fixed_variables_preprocessing = 0\n</code></pre>"},{"location":"api/solver/#qubosolver.solver.QuboSolverClassical","title":"<code>QuboSolverClassical(instance, config=None)</code>","text":"<p>               Bases: <code>BaseSolver</code></p> <p>Classical solver for QUBO problems. This implementation delegates the classical solving task to the external classical solver module (e.g., CPLEX, D-Wave SA, or D-Wave Tabu), as selected via the SolverConfig.</p> <p>After obtaining the raw solution, postprocessing (e.g., bit-flip local search) is applied.</p> Source code in <code>qubosolver/solver.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig | None = None):\n    super().__init__(instance, config)\n    # Optionally, you could instantiate Fixtures here for postprocessing:\n    self.fixtures = Fixtures(self.instance, self.config)\n</code></pre>"},{"location":"api/solver/#qubosolver.solver.QuboSolverQuantum","title":"<code>QuboSolverQuantum(instance, config=None)</code>","text":"<p>               Bases: <code>BaseSolver</code></p> <p>Quantum solver that orchestrates the solving of a QUBO problem using embedding, pulse shaping, and quantum execution pipelines.</p> <p>Initialize the QuboSolver with the given problem and configuration.</p> PARAMETER DESCRIPTION <code>instance</code> <p>The QUBO problem to solve.</p> <p> TYPE: <code>QUBOInstance</code> </p> <code>config</code> <p>Solver settings including backend and device.</p> <p> TYPE: <code>SolverConfig</code> DEFAULT: <code>None</code> </p> Source code in <code>qubosolver/solver.py</code> <pre><code>def __init__(self, instance: QUBOInstance, config: SolverConfig | None = None):\n    \"\"\"\n    Initialize the QuboSolver with the given problem and configuration.\n\n    Args:\n        instance (QUBOInstance): The QUBO problem to solve.\n        config (SolverConfig): Solver settings including backend and device.\n    \"\"\"\n    super().__init__(instance, config or SolverConfig(use_quantum=True))\n    self._check_size_limit()\n\n    self.fixtures = Fixtures(self.instance, self.config)\n    self.backend = get_backend(self.config.backend_config)\n    self.embedder = get_embedder(self.instance, self.config, self.backend)\n    self.pulse_shaper = get_pulse_shaper(self.instance, self.config, self.backend)\n\n    self._register: Register | None = None\n    self._pulse: Pulse | None = None\n</code></pre>"},{"location":"api/solver/#qubosolver.solver.QuboSolverQuantum.embedding","title":"<code>embedding()</code>","text":"<p>Generate a physical embedding (register) for the QUBO variables.</p> RETURNS DESCRIPTION <code>Register</code> <p>Atom layout suitable for quantum hardware.</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qubosolver/solver.py</code> <pre><code>def embedding(self) -&gt; Register:\n    \"\"\"\n    Generate a physical embedding (register) for the QUBO variables.\n\n    Returns:\n        Register: Atom layout suitable for quantum hardware.\n    \"\"\"\n    self.embedder.instance = self.instance\n    self._register = self.embedder.embed()\n    return self._register\n</code></pre>"},{"location":"api/solver/#qubosolver.solver.QuboSolverQuantum.pulse","title":"<code>pulse(embedding)</code>","text":"<p>Generate the pulse sequence based on the given embedding.</p> PARAMETER DESCRIPTION <code>embedding</code> <p>The embedded register layout.</p> <p> TYPE: <code>Register</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>A tuple of     - Pulse: Pulse schedule for quantum execution.     - QUBOSolution: Initial solution of generated from pulse shaper</p> <p> TYPE: <code>tuple</code> </p> Source code in <code>qubosolver/solver.py</code> <pre><code>def pulse(self, embedding: Register) -&gt; tuple:\n    \"\"\"\n    Generate the pulse sequence based on the given embedding.\n\n    Args:\n        embedding (Register): The embedded register layout.\n\n    Returns:\n        tuple:\n            A tuple of\n                - Pulse: Pulse schedule for quantum execution.\n                - QUBOSolution: Initial solution of generated from pulse shaper\n\n    \"\"\"\n    pulse, qubo_solution = self.pulse_shaper.generate(embedding, self.instance)\n\n    self._pulse = pulse\n    return pulse, qubo_solution\n</code></pre>"},{"location":"api/solver/#qubosolver.solver.QuboSolverQuantum.solve","title":"<code>solve()</code>","text":"<p>Execute the full quantum pipeline: preprocess, embed, pulse, execute, postprocess.</p> RETURNS DESCRIPTION <code>QUBOSolution</code> <p>Final result after execution and postprocessing.</p> <p> TYPE: <code>QUBOSolution</code> </p> Source code in <code>qubosolver/solver.py</code> <pre><code>def solve(self) -&gt; QUBOSolution:\n    \"\"\"\n    Execute the full quantum pipeline: preprocess, embed, pulse, execute, postprocess.\n\n    Returns:\n        QUBOSolution: Final result after execution and postprocessing.\n    \"\"\"\n    # 1) try trivial and verify size\n    trivial = self._trivial_solution()\n    if trivial is not None and self.config.activate_trivial_solutions:\n        return trivial\n    self._check_size_limit()\n\n    # 2) else delegate to quantum or classical solver\n    # Delegate the solving task to the appropriate classical solver using the factory\n    if self.config.do_preprocessing:\n        # Apply preprocessing and change the solved QUBO by the reduced one\n        self.fixtures.preprocess()\n        if (\n            self.fixtures.reduced_qubo.coefficients is not None\n            and len(self.fixtures.reduced_qubo.coefficients) &gt; 0\n        ):\n\n            self.instance = self.fixtures.reduced_qubo\n            self.n_fixed_variables_preprocessing = self.fixtures.n_fixed_variables\n\n    embedding = self.embedding()\n\n    pulse, qubo_solution = self.pulse(embedding)\n\n    bitstrings, counts, _, _ = (\n        qubo_solution.bitstrings,\n        qubo_solution.counts,\n        qubo_solution.probabilities,\n        qubo_solution.costs,\n    )\n    if (\n        len(bitstrings) == 0 and qubo_solution.counts is None\n    ) or self.config.pulse_shaping.re_execute_opt_pulse:\n        bitstrings, counts = self.execute(pulse, embedding)\n\n    bitstring_strs = bitstrings\n    bitstrings_tensor = torch.tensor(\n        [list(map(int, bs)) for bs in bitstring_strs], dtype=torch.float32\n    )\n    if counts is None:\n        counts_tensor = torch.empty((0,), dtype=torch.int32)\n    elif isinstance(counts, dict) or isinstance(counts, Counter):\n        count_values = [counts.get(bs, 0) for bs in bitstring_strs]\n        counts_tensor = torch.tensor(count_values, dtype=torch.int32)\n    else:\n        counts_tensor = counts\n\n    solution = QUBOSolution(\n        bitstrings=bitstrings_tensor,\n        counts=counts_tensor,\n        costs=torch.Tensor(),\n        probabilities=None,\n    )\n\n    # Post-process fixations of the preprocessing and restore the original QUBO\n    if self.config.do_preprocessing:\n        solution = self.fixtures.post_process_fixation(solution)\n        self.instance = self.fixtures.instance\n\n    solution.costs = solution.compute_costs(self.instance)\n\n    solution.probabilities = solution.compute_probabilities()\n    solution.sort_by_cost()\n\n    if self.config.do_postprocessing:\n        solution = self.fixtures.postprocess(solution)\n\n    return solution\n</code></pre>"},{"location":"content/backend/","title":"Using backends","text":"<p>In <code>SolverConfig</code>, we can specify the backend to use when using a quantum approach. Several backends are available via <code>Qooqit</code>.</p>"},{"location":"content/backend/#backend-configuration","title":"Backend configuration","text":"<p>The backend configuration part is set via the <code>BackendConfig</code> class.</p> Field Type Description <code>backend</code> <code>BackendType</code> (optional) Which backend to use (e.g., <code>'qutip'</code>, <code>'emu_mps'</code>, <code>'emu_sv'</code>, <code>'remote_qpu'</code>, <code>'remote_emumps'</code>). <code>username</code> <code>str</code> (optional) Username for Pasqal Cloud authentication. Only used for remote backends. <code>password</code> <code>str</code> (optional) Password for Pasqal Cloud authentication. Only used for remote backends. <code>project_id</code> <code>str</code> (optional) Project ID for accessing remote Pasqal services. Only used for remote backends. <code>device</code> <code>NamedDevice</code> | <code>DeviceType</code> | <code>None</code> (optional) If <code>None</code>, the backend will pick a reasonable device. If <code>DeviceType</code>, choose a device by its capabilities, e.g. <code>DeviceType.DIGITAL_ANALOG</code>. If <code>NamedDevice</code>, requiest a specific device. Only remote backends make use of <code>NamedDevice</code>. <code>dt</code> <code>float</code> (optional) For a backend that supports customizing the duration of steps, the timestep size can be provided. As of this writing, this parameter is used only by the EmuMPS backends. <code>wait</code> <code>bool</code> (optional) For a remote backend where we submit a batch of jobs, block execution on this statement until all the submitted jobs are terminated. Defaults to False."},{"location":"content/backend/#local-backends","title":"Local backends","text":"<p>Local backends perform simulations locally. The available backends are:</p> <ul> <li><code>qutip</code> using the Qutip simulator,</li> <li><code>emu_mps</code>: emulator based on state of the art tensor network techniques,</li> <li><code>emu_sv</code>: emulator based on state-vector description.</li> </ul> <p>To use any, simply instantiate a <code>SolverConfig</code> with a <code>BackendConfig</code> as follows:</p> <pre><code>from qubosolver.config import SolverConfig, BackendConfig\nfrom qoolqit._solvers.types import DeviceType\n\nbackend_config = BackendConfig(backend=\"qutip\", device=DeviceType.DIGITAL_ANALOG_DEVICE,)\n\nconfig = SolverConfig(\n    use_quantum=True,\n    backend_config = backend_config,\n)\n</code></pre> <p>Alternatively use the <code>SolverConfig.from_kwargs</code> method with the <code>BackendConfig</code> parameters:</p> <pre><code>from qubosolver.config import SolverConfig\nfrom qoolqit._solvers.types import DeviceType\n\nconfig = SolverConfig.from_kwargs(\n    use_quantum=True,\n    backend=\"qutip\",\n    device=DeviceType.DIGITAL_ANALOG_DEVICE\n)\n</code></pre>"},{"location":"content/backend/#remote-backends","title":"Remote backends","text":"<p>Remote backends submit jobs to a remote server via pasqal-cloud. For this, we require specifying in <code>BackendConfig</code> the <code>project_id</code>, <code>username</code> and <code>password</code>. We can target a remote QPU, or emulator among the choices:</p> <ul> <li><code>remote_qpu</code>,</li> <li><code>remote_emumps</code>,</li> <li><code>remote_emutn</code>,</li> <li><code>remote_emufree</code>: remote emulator based on <code>Qutip</code>.</li> </ul> <pre><code>from qubosolver.config import SolverConfig, BackendConfig\nfrom qoolqit._solvers.types import DeviceType\n\nbackend_config = BackendConfig(backend=\"remote_emufree\", device=DeviceType.DIGITAL_ANALOG_DEVICE, project_id='pid', username='admin', password='pwd')\n\nconfig = SolverConfig(\n    use_quantum=True,\n    backend_config = backend_config,\n)\n</code></pre>"},{"location":"content/config/","title":"SolverConfig \u2013 Solver Configuration Reference","text":"<p>The <code>SolverConfig</code> class defines how a QUBO problem should be solved \u2014 specifying whether to use a quantum or classical approach, which backend to run on, and additional execution parameters.</p> <p>This configuration is passed into any solver (e.g., <code>QuboSolver</code>) and guides its behavior. Note that <code>SolverConfig</code> uses four other configuration objects: 'BackendConfig', <code>EmbeddingConfig</code>, <code>ClassicalConfig</code> and <code>PulseShapingConfig</code>. Besides <code>ClassicalConfig</code>, the other configurations represents different parts of the solver when using a quantum approach:</p>"},{"location":"content/config/#fields-for-solverconfig","title":"Fields for SolverConfig","text":""},{"location":"content/config/#generic-parameters","title":"Generic parameters","text":"Field Type Description <code>config_name</code> <code>str</code> The name of the current configuration <code>use_quantum</code> <code>bool</code> Whether to solve using a quantum approach (<code>True</code>) such as QAA or VQA or a classical approach (<code>False</code>). <code>backend_config</code> <code>BackendConfig</code> Backend part configuration of the solver. <code>n_calls</code> <code>int</code> | <code>None</code> Number of optimization rounds taken to find the best set of parameters for the optimization process inside VQA. The minimum value is 20. Note the optimizer accepts a minimal value of 12. <code>embedding</code> <code>EmbeddingConfig</code> Embedding part configuration of the solver. <code>pulse_shaping</code> <code>PulseShapingConfig</code> Pulse-shaping part configuration of the solver. <code>classical</code> <code>ClassicalConfig</code> Classical part configuration of the solver. <code>num_shots</code> <code>int</code> Number of samples when using a quantum device. Defaults to 500."},{"location":"content/config/#backend-configuration","title":"Backend configuration","text":"<p>The backend configuration part (the <code>backend_config</code> field) is set via the <code>BackendConfig</code> class. It defines how we will run our quantum programs (via a local emulator, or via remote connection).</p> Field Type Description <code>backend</code> <code>BackendType</code> (optional) Which backend to use (e.g., <code>'qutip'</code>, <code>'emu_mps'</code>, <code>'emu_sv'</code>, <code>'remote_qpu'</code>, <code>'remote_emumps'</code>). <code>device</code> <code>NamedDevice</code> | <code>DeviceType</code> | <code>None</code> (optional) If <code>None</code>, the backend will pick a reasonable device. If <code>DeviceType</code>, choose a device by its capabilities, e.g. <code>DeviceType.DIGITAL_ANALOG</code>. If <code>NamedDevice</code>, requiest a specific device. Only remote backends make use of <code>NamedDevice</code>. <code>project_id</code> <code>str</code> (optional) Project ID for accessing remote Pasqal services. Only used for remote backends. <code>username</code> <code>str</code> (optional) Username for Pasqal Cloud authentication. Only used for remote backends. <code>password</code> <code>str</code> (optional) Password for Pasqal Cloud authentication. Only used for remote backends."},{"location":"content/config/#embedding-configuration","title":"Embedding configuration","text":"<p>When solving with a quantum approach, we need to define an embedding method, that is how we define the geometry (register) of atoms based on the QUBO instance and compatibility with a device. The embedding configuration part (the <code>embedding</code> field of <code>SolverConfig</code>) can be divided into two groups of parameters.</p>"},{"location":"content/config/#method-parameter","title":"Method parameter","text":"Field Type Description <code>embedding_method</code> <code>str</code> | <code>EmbedderType</code> | <code>Type[BaseEmbedder]</code> The type of embedding method used to place atoms on the register according to the QUBO problem. (e.g., 'blade', 'greedy', but we can also create our own custom embedding method). <code>draw_steps</code> <code>bool</code> Show generated graph at each step of the optimization. Defaults to False."},{"location":"content/config/#blade-embedding-parameters","title":"BLaDE embedding parameters","text":"Field Type Description <code>blade_dimensions</code> <code>list[int]</code> A list of dimension degrees to explore one after the other (default is [5, 4, 3, 2, 2, 2]). <code>starting_positions</code> <code>torch.Tensor</code> The starting parameters according to the specified dimensions. <code>blade_steps_per_round</code> <code>int</code> | <code>None</code> The number of steps for each layer of dimension for the BLaDE embedder method. Defaults to 200."},{"location":"content/config/#greedy-embedding-parameters","title":"Greedy embedding parameters","text":"<p>We made available a greedy embedding method (given a fixed lattice or layout, it will defines the register to minimize the incremental mismatch between the logical QUBO matrix Q and the physical device interactions), whose related fields are:</p> Field Type Description <code>layout_greedy_embedder</code> <code>str</code> | <code>LayoutType</code> | <code>None</code> Type of layout to run the greedy embedder method on (e.g., 'SquareLatticeLayout', 'TriangularLatticeLayout'). <code>traps</code> <code>int</code> | <code>None</code> The number of traps on the register. <code>spacing</code> <code>int</code> | <code>None</code> The minimum distance between atoms. <code>density</code> <code>int</code> | <code>None</code> The estimated density of the QUBO matrix for the greedy algorithm."},{"location":"content/config/#pulse-shaping-configuration","title":"Pulse Shaping configuration","text":"<p>Quantum devices can be programmed by specifying a sequence of pulses. The pulse shaping configuration part (the <code>pulse_shaping</code> field of <code>SolverConfig</code>) is set via the <code>PulseShapingConfig</code> class, and defines how the pulse parameters are constructed (in an adiabatic fashion, via optimization, ...).</p> Field Type Description <code>pulse_shaping_method</code> <code>str</code> | <code>PulseType</code> | <code>Type[BasePulseShaper]</code> The type of pulse-shaping method used (e.g., 'adiabatic', 'optimized'). <code>initial_omega_parameters</code> <code>list[float]</code> The list of initial amplitude \\(\\Omega\\) parameters (\\(3\\) floating numbers) to be used in the first round of optimization. <code>initial_detuning_parameters</code> <code>list[float]</code> The list of global detuning \\(\\delta\\) parameters (\\(3\\) floating numbers) to be used in the first round of optimization. <code>re_execute_opt_pulse</code> <code>bool</code> Whether to re-run the optimal pulse sequence. <code>custom_qubo_cost</code> <code>callable</code> | <code>None</code> To apply a different qubo cost evaluation than the default. Must be defined as: <code>def custom_qubo_cost(bitstring: str, QUBO: torch.Tensor) -&gt; float</code>. <code>custom_objective_fn</code> <code>callable</code> | <code>None</code> Change the bayesian optimization objective. Instead of using the best cost (<code>best_cost</code>) out of the samples, one can change the objective for an average, or any function out of the form <code>cost_eval = custom_objective_fn(bitstrings, counts, probabilities, costs, best_cost, best_bitstring)</code> <code>callback_objective</code> <code>callable</code> | <code>None</code> Apply a callback during bayesian optimization. Only accepts one input dictionary created during optimization <code>d = {\"x\": x, \"cost_eval\": cost_eval}</code> hence should be defined as: <code>def callback_fn(d: dict) -&gt; None:</code>."},{"location":"content/config/#classical-solver-configuration","title":"Classical solver configuration","text":"<p>For the classical solver, its configuration can be set via the <code>ClassicalConfig</code> class:</p> Field Type Description <code>classical_solver_type</code> <code>str</code> Classical solver type. <code>cplex_maxtime</code> <code>float</code> CPLEX maximum runtime. <code>cplex_log_path</code> <code>str</code> CPLEX logging path."},{"location":"content/config/#pre-post-processing-parameters","title":"Pre-Post processing parameters","text":"<p>We can also apply preprocessing of the QUBO instance (to reduce it to another smaller instance) or postprocessing the solution after solving.</p> Field Type Description <code>do_postprocessing</code> <code>bool</code> Whether we apply post-processing (<code>True</code>) or not (<code>False</code>). <code>do_preprocessing</code> <code>bool</code> Whether we apply pre-processing (<code>True</code>) or not (<code>False</code>)."},{"location":"content/config/#example","title":"Example","text":"<p>The <code>SolverConfig</code> is designed in such way that all parameters have a default value which fulfilled the minimum required configuration to execute the necessary steps to solve a QUBO.</p> <p>All the parameters are <code>Optional</code> which allows for running <code>SolverConfig</code> without specifying any parameter: <pre><code>from qubosolver.config import SolverConfig\nfrom qoolqit._solvers.types import BackendType, DeviceType\nfrom qubosolver.qubo_types import EmbedderType\n\nconfig = SolverConfig()\nconfig.print_specs()\n</code></pre>  which returns the following default specifications: <pre><code>config_name: ''\nuse_quantum: False\nbackend: qutip\ndevice: DeviceType.DIGITAL_ANALOG_DEVICE\nproject_id: ''\nusername: ''\npassword: ''\nn_calls: 20\nembedding: {'embedding_method': &lt;EmbedderType.GREEDY: 'greedy'&gt;, 'layout_greedy_embedder': &lt;LayoutType.SQUARE: &lt;class 'pulser.register.special_layouts.SquareLatticeLayout'&gt;&gt;, 'draw_steps': False, 'traps': 1, 'spacing': 5.0, 'density': None}\npulse_shaping: {'pulse_shaping_method': &lt;PulseType.ADIABATIC: 'adiabatic'&gt;, 'initial_omega_parameters': [5.0, 10.0, 5.0,], 'initial_detuning_parameters': [-10.0, 0.0, 10.0], 're_execute_opt_pulse': False}\nclassical: {'classical_solver_type': 'cplex', 'cplex_maxtime': 600.0, 'cplex_log_path': 'solver.log'}\ndo_postprocessing: False\ndo_preprocessing: False\n</code></pre> Although the default configuration is straightforward, all parameters can be modified by the user to better suit the specific QUBO instance. Below is an example of a configuration that uses a different embedder with customized parameters on a specific device: <pre><code>from qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig, EmbeddingConfig, BackendConfig\nfrom qoolqit._solvers.types import DeviceType\n\ncoefficients = [[0, 1, 2], [1, 0, 3], [2, 3, 0]]\ninstance = QUBOInstance(coefficients=coefficients)\n\nembedding_config = EmbeddingConfig(embedding_method=\"greedy\", traps=instance.size)\nbackend_config = BackendConfig(backend=\"qutip\", device=DeviceType.DIGITAL_ANALOG_DEVICE,)\n\nconfig = SolverConfig(\n    config_name=\"my_config\",\n    use_quantum=True,\n    backend_config = backend_config,\n    embedding = embedding_config,\n)\n</code></pre> </p> <p>Equivalently, one can instantiate a <code>SolverConfig</code> simply using the keyword arguments of the other configs via the <code>SolverConfig.from_kwargs</code> method:</p> <pre><code>from qubosolver import QUBOInstance\nfrom qoolqit._solvers.types import DeviceType\nfrom qubosolver.config import SolverConfig\n\ncoefficients = [[0, 1, 2], [1, 0, 3], [2, 3, 0]]\ninstance = QUBOInstance(coefficients=coefficients)\n\nconfig = SolverConfig.from_kwargs(\n    config_name=\"my_config\",\n    use_quantum=True,\n    backend=\"qutip\",\n    device=DeviceType.ANALOG_DEVICE,\n    embedding_method=\"greedy\",\n    traps=instance.size\n)\n</code></pre>"},{"location":"content/embedding/","title":"Embedding workflow","text":"<p>Here is a breakdown of the current workflow implementation for the embedding of a QUBO matrix, using several embedding methods and parameters.</p>"},{"location":"content/embedding/#using-default-configuration","title":"Using default configuration","text":"<p>The <code>SolverConfig()</code> without argument has a default behavior (e.g. Solver Config page) that allows for embedding using the minimum configuration according to the device.</p>"},{"location":"content/embedding/#code-example","title":"Code example","text":"<pre><code>import torch\n\nfrom qubosolver.config import SolverConfig, EmbeddingConfig, BackendConfig\nfrom qubosolver.solver import QUBOInstance, QuboSolver\n\n# define qubo matrix\ncoefficients = torch.tensor([[0, 1, 2], [1, 0, 3], [2, 3, 0]])\n\n# Instantiate a QUBOInstance with coefficients\ninstance = QUBOInstance(coefficients)\n\n# define the solver with default configuration\ndefault_config = SolverConfig()\nsolver = QuboSolver(instance, default_config)\ngeometry = solver.embedding()\n\n# draw the register\n# geometry.register.draw()\n</code></pre>"},{"location":"content/embedding/#blade-config","title":"BLaDE config","text":"<p>The following configuration uses the BLaDE method with specific dimension layers and a number of steps per round (i.e. the number of iterations per layer). Starting positions are implicitely defined but it can be set here, as long as it matches the first dimension layer.</p> <pre><code>embedconfig = EmbeddingConfig(embedding_method=\"blade\", blade_dimensions=[5, 4, 3, 2], blade_steps_per_round=300)\nblade_config = SolverConfig(\n    use_quantum=True,\n    embedding=embedconfig,\n)\n\nsolver = QuboSolver(instance, blade_config)\ngeometry = solver.embedding()\n\n# geometry.register.draw()\n</code></pre>"},{"location":"content/embedding/#greedy-embedder-config","title":"Greedy embedder config","text":"<p>The following uses the greedy embedding method on a triangular lattice layout with a number of traps equals to the size of the QUBO. It also allows working on a square lattice layout, as well as increasing the number of traps according to the device specifications.</p> <pre><code>from qoolqit._solvers.types import DeviceType\n\nembedconfig = EmbeddingConfig(embedding_method=\"greedy\", traps=instance.size, layout_greedy_embedder=\"triangular\",)\nbackend = BackendConfig(device=DeviceType.ANALOG_DEVICE)\ngreedy_config = SolverConfig(\n    use_quantum=True,\n    embedding=embedconfig,\n    backend_config = backend,\n)\n\nsolver = QuboSolver(instance, greedy_config)\ngeometry = solver.embedding()\n\n# geometry.register.draw()\n</code></pre>"},{"location":"content/embedding/#custom-embedder-config","title":"Custom embedder config","text":"<p>If one desires to develop his own embedding method, a subclass of <code>qubosolver.pipeline.embedder.BaseEmbedder</code> should be implemented with a mandatory <code>embed</code> method.</p> <p>The <code>embed</code> method <code>def embed(self) -&gt; qubosolver.pipeline.targets.Register</code> specify how the problem is mapped into a register of qubits when running using a quantum device. Let us show a simple example where each variable \\(i\\) is mapped into a qubit lying on a horizontal line (with coordinates \\([i, 0]\\)).</p> <pre><code>import typing\nfrom qubosolver.pipeline.embedder import BaseEmbedder\nfrom qubosolver.pipeline.targets import Register as TargetRegister\nfrom qubosolver.config import (\n    EmbeddingConfig,\n    SolverConfig,\n)\nfrom pulser.register import Register as PulserRegister\n\nclass FixedEmbedder(BaseEmbedder):\n\n    @typing.no_type_check\n    def embed(self) -&gt; TargetRegister:\n        qubits = {f\"q{i}\": (i,0) for i in range(self.instance.coefficients.shape[0])}\n        register = PulserRegister(qubits)\n        return TargetRegister(self.config.backend_config.device, register)\n\n\nconfig = SolverConfig(\n    use_quantum=True,\n    embedding=EmbeddingConfig(embedding_method=FixedEmbedder),\n)\n</code></pre>"},{"location":"content/qubo_analyzer/","title":"Analyzing qubo solutions","text":""},{"location":"content/qubo_analyzer/#quboanalyzer-example","title":"QUBOAnalyzer example","text":"<p>To analyze the solutions from one or many QUBO solvers, we can instantiate a <code>QUBOAnalyzer</code> with solutions and labels as follows:</p> <pre><code>import torch\nfrom qubosolver.data import QUBOSolution\nfrom qubosolver.qubo_analyzer import QUBOAnalyzer\n\nnum_bitstrings=100\nbit_length=3\n\ncosts = torch.randint(1, 20, (2**bit_length,), dtype=torch.float)\n\nbitstrings = torch.randint(0, 2, (num_bitstrings, bit_length))\nbitstrings,counts=bitstrings.unique(dim=0,return_counts=True)\nsolution1 = QUBOSolution(bitstrings, costs, counts)\n\nbitstrings = torch.randint(0, 2, (num_bitstrings, bit_length))\nbitstrings,counts=bitstrings.unique(dim=0,return_counts=True)\nsolution2 = QUBOSolution(bitstrings, costs, counts)\n\n# Create the analyzer with our two solutions\nanalyzer = QUBOAnalyzer([solution1, solution2], labels=[\"sol1\", \"sol2\"])\ndf = analyzer.df\n</code></pre> <p>This will generate a pandas dataframe internally (accessible via the <code>df</code> attribute) for several <code>QUBOAnalyzer</code> methods for plotting or comparing solutions, described below. More examples are demonstrated in the <code>QUBOAnalyzer</code> tutorial.</p>"},{"location":"content/qubo_analyzer/#quboanalyzer-api-description","title":"QUBOAnalyzer API description","text":""},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer","title":"<code>QUBOAnalyzer(solutions, labels=None)</code>","text":"<p>Analyzer for solutions to a Quadratic Unconstrained Binary Optimization (QUBO) problem.</p> <p>Initializes the analyzer with one or a list of QUBOSolutions.</p> <p>If a single QUBOSolution is provided, it is automatically wrapped into a list. Optionally, you can provide a list of labels corresponding to each QUBOSolution. If labels are not provided, they are assigned automatically as '0', '1', etc.</p> PARAMETER DESCRIPTION <code>solutions</code> <p>A single QUBOSolution or a list of QUBOSolution instances.</p> <p> TYPE: <code>QUBOSolution | list[QUBOSolution]</code> </p> <code>labels</code> <p>A list of labels for the QUBOSolutions. Must match the number of solutions.</p> <p> TYPE: <code>str | list[str] | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If no solutions are provided or if the number of labels         does not match the number of solutions.</p> <code>TypeError</code> <p>If any solution or label is not of the expected type.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def __init__(\n    self,\n    solutions: QUBOSolution | list[QUBOSolution],\n    labels: str | list[str] | None = None,\n):\n    \"\"\"\n    Analyzer for solutions to a Quadratic Unconstrained Binary Optimization (QUBO) problem.\n\n    Initializes the analyzer with one or a list of QUBOSolutions.\n\n    If a single QUBOSolution is provided, it is automatically wrapped into a list.\n    Optionally, you can provide a list of labels corresponding to each QUBOSolution.\n    If labels are not provided, they are assigned automatically as '0', '1', etc.\n\n    Args:\n        solutions (QUBOSolution | list[QUBOSolution]):\n            A single QUBOSolution or a list of QUBOSolution instances.\n        labels (str | list[str] | None):\n            A list of labels for the QUBOSolutions. Must match the number of solutions.\n\n    Raises:\n        ValueError: If no solutions are provided or if the number of labels\n                    does not match the number of solutions.\n        TypeError: If any solution or label is not of the expected type.\n    \"\"\"\n    # Recast solutions into a list if a single solution is provided.\n    if not isinstance(solutions, list):\n        solutions = [solutions]\n\n    for sol in solutions:\n        if not isinstance(sol, QUBOSolution):\n            raise TypeError(\"Each solution must be a QUBOSolution instance.\")\n\n    self.solutions = solutions\n\n    # Validate labels if provided.\n    if labels is not None:\n        # Recast labels into a list if a single solution is provided.\n        if not isinstance(labels, list):\n            labels = [labels]\n\n        if len(labels) != len(solutions):\n            raise ValueError(\n                \"The number of labels must equal the number of QUBOSolutions provided.\"\n            )\n        for label in labels:\n            if not isinstance(label, str):\n                raise TypeError(\"Each label must be a string.\")\n        self.labels = labels\n    else:\n        self.labels = [str(i) for i in range(len(solutions))]\n\n    self.df = self._to_dataframe()\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.add_counts","title":"<code>add_counts(counts)</code>","text":"<p>Updates the DataFrame by adding the counts column.</p> <p>If counts are provided at a later stage, this method will add the counts to the DataFrame and ensure that they match the number of bitstrings.</p> PARAMETER DESCRIPTION <code>counts</code> <p>A list or tensor of counts.</p> <p> TYPE: <code>list[int] | Tensor</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the length of counts does not match the number of bitstrings.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def add_counts(self, counts: list[int] | torch.Tensor) -&gt; None:\n    \"\"\"\n    Updates the DataFrame by adding the counts column.\n\n    If counts are provided at a later stage, this method will add the counts\n    to the DataFrame and ensure that they match the number of bitstrings.\n\n    Args:\n        counts (list[int] | torch.Tensor): A list or tensor of counts.\n\n    Raises:\n        ValueError: If the length of counts does not match the number of bitstrings.\n    \"\"\"\n    if isinstance(counts, torch.Tensor):\n        counts = counts.tolist()  # Convert tensor to list if necessary\n\n    if len(counts) != len(self.df):\n        raise ValueError(\n            \"The number of counts must match\" \" the number of bitstrings in the DataFrame.\"\n        )\n\n    if _PROBS in self.df.columns:\n        # Check if the probabilities are consistent\n        # with the counts (probs = counts / total_counts)\n        total_counts = sum(self.df[_COUNTS])\n        expected_counts = [probs * total_counts for probs in self.df[_PROBS]]\n        if not all(abs(p - ep) &lt; 1e-6 for p, ep in zip(counts, expected_counts)):\n            raise ValueError(\"The provided counts do not match probabilities.\")\n\n    self.df[_COUNTS] = counts\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.add_probs","title":"<code>add_probs(probs)</code>","text":"<p>Updates the DataFrame by adding the probs column.</p> <p>If probs are provided at a later stage, this method will add the probs to the DataFrame and ensure that they match the number of bitstrings.</p> PARAMETER DESCRIPTION <code>probs</code> <p>A list or tensor of probabilities.</p> <p> TYPE: <code>list[float] | Tensor</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the length of probabilities does not match the number of bitstrings.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def add_probs(self, probs: list[float] | torch.Tensor) -&gt; None:\n    \"\"\"\n    Updates the DataFrame by adding the probs column.\n\n    If probs are provided at a later stage, this method will add the probs\n    to the DataFrame and ensure that they match the number of bitstrings.\n\n    Args:\n        probs (list[float] | torch.Tensor): A list or tensor of probabilities.\n\n    Raises:\n        ValueError: If the length of probabilities does not match the number of bitstrings.\n    \"\"\"\n    if isinstance(probs, torch.Tensor):\n        probs = probs.tolist()\n\n    if len(probs) != len(self.df):\n        raise ValueError(\n            \"The number of counts must match\" \"the number of bitstrings in the DataFrame.\"\n        )\n\n    if _COUNTS in self.df.columns:\n        # Check if the probabilities are consistent\n        # with the counts (probs = counts / total_counts)\n        total_counts = sum(self.df[_COUNTS])\n        expected_probs = [count / total_counts for count in self.df[_COUNTS]]\n        if not all(abs(p - ep) &lt; 1e-6 for p, ep in zip(probs, expected_probs)):\n            raise ValueError(\"The provided probabilities do not match counts.\")\n\n    self.df[_PROBS] = probs\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.average_cost","title":"<code>average_cost(top_percent=1)</code>","text":"<p>Calculates the average cost for the best top_percent of bitstrings (lowest cost) for each solution.</p> PARAMETER DESCRIPTION <code>top_percent</code> <p>A fraction between 0 and 1 representing the percentage                  of lowest cost bitstrings to consider.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame with each solution label, the average cost over the           best top_percent bitstrings, and the count of bitstrings used.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def average_cost(self, top_percent: float = 1) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the average cost for the best top_percent of bitstrings (lowest cost)\n    for each solution.\n\n    Args:\n        top_percent (float): A fraction between 0 and 1 representing the percentage\n                             of lowest cost bitstrings to consider.\n\n    Returns:\n        pd.DataFrame: A DataFrame with each solution label, the average cost over the\n                      best top_percent bitstrings, and the count of bitstrings used.\n    \"\"\"\n    df_top = self.filter_by_percentage(top_percent)\n    results = []\n    for label, group in df_top.groupby(_LABELS):\n        avg_cost = group[_COSTS].mean()\n        results.append(\n            {\n                _LABELS: label,\n                \"average cost\": avg_cost,\n                \"bitstrings considered\": len(group),\n            }\n        )\n\n    return pd.DataFrame(results)\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.best_bitstrings","title":"<code>best_bitstrings()</code>","text":"<p>Finds all unique bitstrings (with the best cost) in each solution's DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: A DataFrame with all unique rows per solution (solution_label)           that have the best (lowest) cost.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def best_bitstrings(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Finds all unique bitstrings (with the best cost) in each solution's DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame with all unique rows per solution (solution_label)\n                      that have the best (lowest) cost.\n    \"\"\"\n    best_list = []\n    for label, sol in self.df.groupby(_LABELS):\n        min_cost = sol[_COSTS].min()\n        # Filter all rows with the cost equal to the minimum cost in this group\n        best = sol[sol[_COSTS] == min_cost]\n        # Optionally, drop duplicate bitstring entries (if bitstrings are duplicated)\n        best = best.drop_duplicates(subset=[_BITSTRINGS])\n        best_list.append(best)\n    best_rows = pd.concat(best_list, ignore_index=True)\n    return best_rows\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.bitstrings_to_tensor","title":"<code>bitstrings_to_tensor(bitstring_list)</code>  <code>staticmethod</code>","text":"<p>Converts a list of bitstring strings to a torch tensor of bitstrings.</p> <p>Each bitstring in the list is assumed to be a string of '0's and '1's (e.g., \"010101\"). Converts each character to an integer and constructs a tensor of shape (num_bitstrings, bitstring_length).</p> PARAMETER DESCRIPTION <code>bitstring_list</code> <p>A list of bitstring strings.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>torch.Tensor: A tensor with shape (num_bitstrings, bitstring_length)           with integer elements.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the list is empty or if the bitstrings are not of uniform length.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>@staticmethod\ndef bitstrings_to_tensor(bitstring_list: list[str]) -&gt; torch.Tensor:\n    \"\"\"\n    Converts a list of bitstring strings to a torch tensor of bitstrings.\n\n    Each bitstring in the list is assumed to be a string of '0's and '1's (e.g., \"010101\").\n    Converts each character to an integer and constructs a tensor of shape\n    (num_bitstrings, bitstring_length).\n\n    Args:\n        bitstring_list (list[str]): A list of bitstring strings.\n\n    Returns:\n        torch.Tensor: A tensor with shape (num_bitstrings, bitstring_length)\n                      with integer elements.\n\n    Raises:\n        ValueError: If the list is empty or if the bitstrings are not of uniform length.\n    \"\"\"\n    if not bitstring_list:\n        raise ValueError(\"The bitstring_list is empty.\")\n    bit_length = len(bitstring_list[0])\n    for bitstr in bitstring_list:\n        if len(bitstr) != bit_length:\n            raise ValueError(\"All bitstrings must have the same length.\")\n    bit_lists = [[int(x) for x in bitstr] for bitstr in bitstring_list]\n    return torch.tensor(bit_lists, dtype=torch.int)\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.calculate_costs","title":"<code>calculate_costs(Q)</code>","text":"<p>Calculates the cost for each bitstring using the provided Q QUBOInstance.</p> <pre><code>cost = x^T Q x\n</code></pre> <p>The computed cost is added as the columns _COSTS in the DataFrame.</p> PARAMETER DESCRIPTION <code>Q</code> <p>QUBOInstance</p> <p> TYPE: <code>QUBOInstance</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: The updated DataFrame including the _COSTS column.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If a bitstring's length does not match Q.shape[0].</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def calculate_costs(self, Q: QUBOInstance) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the cost for each bitstring using the provided Q QUBOInstance.\n\n        cost = x^T Q x\n\n    The computed cost is added as the columns _COSTS in the DataFrame.\n\n    Args:\n        Q: QUBOInstance\n\n    Returns:\n        pd.DataFrame: The updated DataFrame including the _COSTS column.\n\n    Raises:\n        ValueError: If a bitstring's length does not match Q.shape[0].\n    \"\"\"\n\n    self.df[_COSTS] = self.df[_BITSTRINGS].apply(Q.evaluate_solution)\n    return self.df\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.calculate_gaps","title":"<code>calculate_gaps(opt_cost, Q=None)</code>","text":"<p>Calculates the gaps for each bitstring using the provided optimal cost. If costs aren ot present calculates costs as</p> <pre><code>    cost = x^T Q x\n</code></pre> <p>The computed cost is added as the columns _COSTS in the DataFrame.</p> PARAMETER DESCRIPTION <code>Q</code> <p>QUBOInstance</p> <p> TYPE: <code>QUBOInstance | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: The updated DataFrame including the _COSTS column.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If a bitstring's length does not match Q.shape[0].</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def calculate_gaps(self, opt_cost: float, Q: QUBOInstance | None = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculates the gaps for each bitstring using the provided optimal cost.\n    If costs aren ot present calculates costs as\n\n            cost = x^T Q x\n\n    The computed cost is added as the columns _COSTS in the DataFrame.\n\n    Args:\n        Q: QUBOInstance\n\n    Returns:\n        pd.DataFrame: The updated DataFrame including the _COSTS column.\n\n    Raises:\n        ValueError: If a bitstring's length does not match Q.shape[0].\n    \"\"\"\n    if _COSTS in self.df.columns:\n        self.df[_GAPS] = abs((self.df[_COSTS] - opt_cost) / opt_cost)\n    else:\n        if Q is not None:\n            self.df[_COSTS] = self.df[_BITSTRINGS].apply(Q.evaluate_solution)\n        else:\n            self.df[_GAPS] = abs((self.df[_COSTS] - opt_cost) / opt_cost)\n    return self.df\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.compare_qubo_solutions","title":"<code>compare_qubo_solutions(target_labels)</code>","text":"<p>Compare two <code>QUBOSolution</code> objects and provide a statistical analysis of the differences, including degenerate solution matching and mismatch statistics.</p> PARAMETER DESCRIPTION <code>target_labels</code> <p>The labels of the solutions to compare. If None, compares all solutions.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def compare_qubo_solutions(\n    self,\n    target_labels: list[str],\n) -&gt; None:\n    \"\"\"\n    Compare two `QUBOSolution` objects and provide a statistical analysis of the differences,\n    including degenerate solution matching and mismatch statistics.\n\n    Args:\n        target_labels (list[str]): The labels of the solutions to compare. If None, compares\n            all solutions.\n    \"\"\"\n\n    def print_diff(\n        diff: set[str],\n        bs_set: set[str],\n        main_label: str,\n        compare_label: str,\n    ) -&gt; None:\n        \"\"\"\n        Prints the differences between two sets of bitstrings.\n        Args:\n            diff (set[str]): The set of bitstrings that are in main_label but not in\n                compare_label.\n            bs_set (set[str]): The set of all unique bitstrings.\n            main_label (str): The label of the solution being compared from.\n            compare_label (str): The label of the solution being compared to.\n        \"\"\"\n        if len(diff) &gt; 0:\n            print(f\"\\nBitstrings in {main_label} not present in {compare_label}:\")\n            for bs in diff:\n                print(\"-\", bs)\n            print(\n                f\"\\nRatio of different bitstrings: {len(diff)}/{len(bs_set)} = \"\n                + f\"{(len(diff)/len(bs_set))*100:.0f}%\"\n            )\n\n    # Validate target labels\n    if len(target_labels) != 2:\n        raise ValueError(\"Exactly two target labels must be provided for comparison.\")\n    if not all(label in self.labels for label in target_labels):\n        raise ValueError(\"All target labels must be present in the QUBOAnalyzer's labels.\")\n\n    # Extract bitstrings for each target label\n    bs_list1 = self.df[self.df[\"labels\"] == target_labels[0]][\"bitstrings\"].tolist()\n    bs_list2 = self.df[self.df[\"labels\"] == target_labels[1]][\"bitstrings\"].tolist()\n\n    # TODO: Once issue about duplicate bitstrings in QUBOSolution is fixed, this can be removed\n    bs_set1 = set(bs_list1)\n    bs_set2 = set(bs_list2)\n\n    print(\n        f\"Comparing two lists of bitstrings:\\n1. {target_labels[0]}: {len(bs_list1)} bitstrings\"\n        + f\" ({len(bs_set1)} unique strings)\\n2. {target_labels[1]}: {len(bs_list2)} bitstrings\"\n        + f\" ({len(bs_set2)} unique strings)\"\n    )\n\n    # Analyze differences\n    diff1 = bs_set1 - bs_set2\n    diff2 = bs_set2 - bs_set1\n\n    if len(diff1) == 0 and len(diff2) == 0:\n        print(\"\\nThe lists contain exactly the same bitstrings.\")\n        return\n    else:\n        print_diff(diff1, bs_set1, target_labels[0], target_labels[1])\n        print_diff(diff2, bs_set2, target_labels[1], target_labels[0])\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.filter_by_cost","title":"<code>filter_by_cost(max_cost, df=None)</code>","text":"<p>Returns a DataFrame limited to bitstrings whose cost is smaller than the provided threshold.</p> PARAMETER DESCRIPTION <code>max_cost</code> <p>Maximum cost threshold.</p> <p> TYPE: <code>float</code> </p> <code>df</code> <p>DataFrame to filter.</p> <p> TYPE: <code>DataFrame | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: The filtered DataFrame.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def filter_by_cost(self, max_cost: float, df: pd.DataFrame | None = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a DataFrame limited to bitstrings whose cost\n    is smaller than the provided threshold.\n\n    Args:\n        max_cost (float): Maximum cost threshold.\n        df (pd.DataFrame | None): DataFrame to filter.\n\n    Returns:\n        pd.DataFrame: The filtered DataFrame.\n    \"\"\"\n\n    if df is None:\n        df = self.df\n\n    if _COSTS not in df.columns:\n        raise ValueError(\"No probabilities available in the DataFrame.\")\n\n    return df[df[_COSTS] &lt; max_cost]\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.filter_by_percentage","title":"<code>filter_by_percentage(top_percent=1.0, column=_COSTS, order='ascending')</code>","text":"<p>Returns a DataFrame limited to the best bitstrings in a given column for each solution group, where \"best\" means that the cumulative probability (_PROBS) of the selected rows reaches at least top_percent. The sorting order is controlled by the <code>order</code> parameter: if \"ascending\", the group is sorted in ascending order (lower values are considered better); if \"descending\", sorted in descending order.</p> PARAMETER DESCRIPTION <code>top_percent</code> <p>A threshold between 0 and 1 representing                  the fraction of cumulative probability.                  For example, 0.1 means select bitstrings                  until their cumulative probability is \u2265 10%.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>column</code> <p>The key (column) by which to sort the rows                     (e.g. _COSTS, _GAPS, or _PROBS).                     Defaults to _COSTS.</p> <p> TYPE: <code>str</code> DEFAULT: <code>_COSTS</code> </p> <code>order</code> <p>Either \"ascending\" or \"descending\". If \"ascending\",          rows are sorted in ascending order (lower values are better).          If \"descending\", rows are sorted in descending order          (higher values are better).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'ascending'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: The filtered DataFrame containing, for each solution group, the bitstrings           whose cumulative probability (_PROBS)         reaches the specified top_percent threshold.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the specified column is not in the DataFrame,         if top_percent is not in (0, 1],         or if the order parameter is not \"descending\" or \"ascending\".</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def filter_by_percentage(\n    self,\n    top_percent: float = 1.0,\n    column: str = _COSTS,\n    order: str = \"ascending\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a DataFrame limited to the best bitstrings\n    in a given column for each solution group,\n    where \"best\" means that the cumulative probability (_PROBS)\n    of the selected rows reaches at least\n    top_percent. The sorting order is controlled by the\n    `order` parameter: if \"ascending\", the group is sorted\n    in ascending order (lower values are considered better);\n    if \"descending\", sorted in descending order.\n\n    Args:\n        top_percent (float): A threshold between 0 and 1 representing\n                             the fraction of cumulative probability.\n                             For example, 0.1 means select bitstrings\n                             until their cumulative probability is \u2265 10%.\n        column (str): The key (column) by which to sort the rows\n                                (e.g. _COSTS, _GAPS, or _PROBS).\n                                Defaults to _COSTS.\n        order (str): Either \"ascending\" or \"descending\". If \"ascending\",\n                     rows are sorted in ascending order (lower values are better).\n                     If \"descending\", rows are sorted in descending order\n                     (higher values are better).\n\n    Returns:\n        pd.DataFrame: The filtered DataFrame containing, for each solution group, the bitstrings\n                      whose cumulative probability (_PROBS)\n                    reaches the specified top_percent threshold.\n\n    Raises:\n        ValueError: If the specified column is not in the DataFrame,\n                    if top_percent is not in (0, 1],\n                    or if the order parameter is not \"descending\" or \"ascending\".\n    \"\"\"\n    df = self.df\n    if column not in df.columns:\n        raise ValueError(\n            f\"{column} data is not available. \\\n                         Please add {column} before filtering.\"\n        )\n\n    if not (0 &lt; top_percent &lt;= 1):\n        raise ValueError(\"top_percent must be a float between 0 and 1.\")\n\n    if order not in (\"ascending\", \"descending\"):\n        raise ValueError(\"The keep parameter must be either 'ascending' or 'descending'.\")\n\n    filtered_list = []\n    for label, group in df.groupby(_LABELS):\n        # Sort the group based on the specified column using the desired order.\n        sorted_group = group.sort_values(by=column, ascending=(order == \"ascending\"))\n        cumulative = 0.0\n        selected_indices = []\n        # Use the _PROBS column to accumulate probability\n        for idx, row in sorted_group.iterrows():\n            cumulative += row[_PROBS]\n            selected_indices.append(idx)\n            if cumulative &gt;= top_percent:\n                break\n\n        filtered_group = sorted_group.loc[selected_indices]\n        filtered_list.append(filtered_group)\n    return pd.concat(filtered_list, ignore_index=True)\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.filter_by_probability","title":"<code>filter_by_probability(min_probability, df=None)</code>","text":"<p>Returns a DataFrame limited to bitstrings whose probability is greater than the provided threshold.</p> PARAMETER DESCRIPTION <code>min_probability</code> <p>Minimum probability threshold.</p> <p> TYPE: <code>float</code> </p> <code>df</code> <p>DataFrame to filter.</p> <p> TYPE: <code>DataFrame | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: The filtered DataFrame.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the 'probabilities' column is not present.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def filter_by_probability(\n    self, min_probability: float, df: pd.DataFrame | None = None\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a DataFrame limited to bitstrings whose probability\n    is greater than the provided threshold.\n\n    Args:\n        min_probability (float): Minimum probability threshold.\n        df (pd.DataFrame | None): DataFrame to filter.\n\n    Returns:\n        pd.DataFrame: The filtered DataFrame.\n\n    Raises:\n        ValueError: If the 'probabilities' column is not present.\n    \"\"\"\n\n    if df is None:\n        df = self.df\n\n    if _PROBS not in df.columns:\n        raise ValueError(\"No probabilities available in the DataFrame.\")\n    return df[df[_PROBS] &gt; min_probability]\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.plot","title":"<code>plot(x_axis, y_axis, labels=None, sort_by=None, sort_order='ascending', probability_threshold=None, cost_threshold=None, top_percent=None, context='notebook')</code>","text":"<p>A wrapper function that chooses between plotting costs, counts, or probabilities as a function of bitstrings or as a function of cost.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>def plot(\n    self,\n    x_axis: str,\n    y_axis: str,\n    labels: list[str] | None = None,\n    sort_by: str | None = None,\n    sort_order: str = \"ascending\",\n    probability_threshold: float | None = None,\n    cost_threshold: float | None = None,\n    top_percent: float | None = None,\n    context: str = \"notebook\",\n) -&gt; sns.axisgrid.FacetGrid:\n    \"\"\"\n    A wrapper function that chooses between plotting costs, counts, or probabilities\n    as a function of bitstrings or as a function of cost.\n    \"\"\"\n    df = self.df.copy()\n\n    if x_axis not in df.columns:\n        raise ValueError(\n            f\"{x_axis} data is not available.\\\n                            Please add {x_axis} before plotting.\"\n        )\n\n    if labels:\n        df = df[df[_LABELS].isin(labels)]\n\n    if probability_threshold is not None:\n        df = self.filter_by_probability(probability_threshold, df)\n\n    if cost_threshold is not None:\n        df = self.filter_by_cost(cost_threshold, df)\n\n    if top_percent is not None:\n        df = self.filter_by_percentage(top_percent)\n\n    if x_axis == _BITSTRINGS:\n        g = self.plot_vs_bitstrings(\n            df=df,\n            y_axis=y_axis,\n            sort_by=sort_by,\n            sort_order=sort_order,\n            context=context,\n        )\n        return g\n    else:\n        g = self.plot_no_bitstrings(\n            df=df,\n            x_axis=x_axis,\n            y_axis=y_axis,\n            sort_by=sort_by,\n            sort_order=sort_order,\n            context=context,\n        )\n        return g\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.plot_no_bitstrings","title":"<code>plot_no_bitstrings(df, x_axis, y_axis, sort_by=None, sort_order='ascending', context='notebook')</code>  <code>staticmethod</code>","text":"<p>Plots a bar chart of probabilities or counts as a function of cost.</p> PARAMETER DESCRIPTION <code>df</code> <p>The DataFrame to plot. Defaults to None,                 that means uses self.df.</p> <p> TYPE: <code>DataFrame</code> </p> <code>x_axis</code> <p>The column name to be plotted on the x-axis.</p> <p> TYPE: <code>str</code> </p> <code>y_axis</code> <p>The column name to be plotted on the y-axis.</p> <p> TYPE: <code>str</code> </p> <code>sort_by</code> <p>Defines the column by which to sort the costs.                      If None, no sorting is done.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>sort_order</code> <p>Defines the sorting order. Accepts 'ascending' or 'descending'.               Default is 'ascending'. Ignored if <code>sort_by</code> is None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'ascending'</code> </p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>@staticmethod\ndef plot_no_bitstrings(\n    df: pd.DataFrame,\n    x_axis: str,\n    y_axis: str,\n    sort_by: str | None = None,\n    sort_order: str = \"ascending\",\n    context: str = \"notebook\",\n) -&gt; sns.axisgrid.FacetGrid:\n    \"\"\"\n    Plots a bar chart of probabilities or counts as a function of cost.\n\n    Args:\n        df (pd.DataFrame): The DataFrame to plot. Defaults to None,\n                            that means uses self.df.\n        x_axis (str): The column name to be plotted on the x-axis.\n        y_axis (str): The column name to be plotted on the y-axis.\n        sort_by (str | None): Defines the column by which to sort the costs.\n                                 If None, no sorting is done.\n        sort_order (str): Defines the sorting order. Accepts 'ascending' or 'descending'.\n                          Default is 'ascending'. Ignored if `sort_by` is None.\n    \"\"\"\n    if x_axis not in df.columns:\n        raise ValueError(\n            f\"{x_axis} data is not available. Please add {x_axis} before plotting.\"\n        )\n\n    if y_axis not in df.columns:\n        raise ValueError(\n            f\"{y_axis} data is not available. Please add {y_axis} before plotting.\"\n        )\n\n    if sort_by:\n        if sort_by not in [x_axis, y_axis]:\n            raise ValueError(f\"{sort_by} is not a valid column for sorting.\")\n\n    df = df.groupby([_LABELS, x_axis], as_index=False).agg({y_axis: \"sum\"})\n    df = df.pivot_table(\n        index=x_axis,\n        columns=_LABELS,\n        values=y_axis,\n        fill_value=0,\n    ).reset_index()\n    df = df.melt(id_vars=x_axis, var_name=_LABELS, value_name=y_axis)\n    df = df.sort_values(by=sort_by, ascending=(sort_order == \"ascending\"))\n\n    # Set color palette\n    cmap = sns.color_palette(\"viridis\", n_colors=len(df[_LABELS].unique().tolist()))\n\n    with sns.plotting_context(context):\n        g = sns.catplot(\n            data=df,\n            x=x_axis,\n            y=y_axis,\n            hue=_LABELS,\n            kind=\"bar\",\n            order=df[x_axis].unique().tolist(),\n            height=6,\n            aspect=1.5,  # This ensures the bars are side by side\n            palette=cmap,\n        )\n\n    # Set axis labels\n    g.set_axis_labels(x_axis, y_axis)\n\n    return g\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.plot_vs_bitstrings","title":"<code>plot_vs_bitstrings(df, y_axis, sort_by=None, sort_order='descending', context='notebook')</code>  <code>staticmethod</code>","text":"<p>Plots a bar chart of costs, counts, or probabilities as a function of bitstrings.</p> PARAMETER DESCRIPTION <code>df</code> <p>The DataFrame to plot. Defaults to None,                 that means uses self.df.</p> <p> TYPE: <code>DataFrame</code> </p> <code>y_axis</code> <p>The column name to be plotted on the y-axis.</p> <p> TYPE: <code>str</code> </p> <code>sort_by</code> <p>Defines the column by which to sort the bitstrings.                      If None, no sorting is done.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>sort_order</code> <p>Defines the sorting order. Accepts 'ascending' or 'descending'.               Default is 'ascending'. Ignored if <code>sort_by</code> is None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'descending'</code> </p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>@staticmethod\ndef plot_vs_bitstrings(\n    df: pd.DataFrame,\n    y_axis: str,\n    sort_by: str | None = None,\n    sort_order: str = \"descending\",\n    context: str = \"notebook\",\n) -&gt; sns.axisgrid.FacetGrid:\n    \"\"\"\n    Plots a bar chart of costs, counts, or probabilities as a function of bitstrings.\n\n    Args:\n        df (pd.DataFrame): The DataFrame to plot. Defaults to None,\n                            that means uses self.df.\n        y_axis (str): The column name to be plotted on the y-axis.\n        sort_by (str | None): Defines the column by which to sort the bitstrings.\n                                 If None, no sorting is done.\n        sort_order (str): Defines the sorting order. Accepts 'ascending' or 'descending'.\n                          Default is 'ascending'. Ignored if `sort_by` is None.\n\n    \"\"\"\n    # Check if the y_axis is available\n    if y_axis not in df.columns:\n        raise ValueError(\n            f\"{y_axis} data is not available.\\\n                          Please add {y_axis} before plotting.\"\n        )\n    if sort_by and sort_by not in df.columns:\n        raise ValueError(f\"{sort_by} is not a valid column for sorting.\")\n\n    if sort_by == y_axis:\n        df = df.pivot_table(\n            index=_BITSTRINGS,\n            columns=_LABELS,\n            values=y_axis,\n            fill_value=0,\n        ).reset_index()\n        df = df.melt(id_vars=_BITSTRINGS, var_name=_LABELS, value_name=y_axis)\n        df = df.sort_values(by=sort_by, ascending=(sort_order == \"ascending\"))\n    else:\n        df = df.pivot_table(\n            index=[_BITSTRINGS, sort_by],\n            columns=_LABELS,\n            values=y_axis,\n            fill_value=0,\n        ).reset_index()\n        df = df.melt(id_vars=[_BITSTRINGS, sort_by], var_name=_LABELS, value_name=y_axis)\n        df = df.sort_values(by=sort_by, ascending=(sort_order == \"ascending\"))\n\n    # Set color palette\n    cmap = sns.color_palette(\"viridis\", n_colors=len(df[_LABELS].unique().tolist()))\n\n    with sns.plotting_context(context):\n        g = sns.catplot(\n            data=df,\n            x=_BITSTRINGS,\n            y=y_axis,\n            hue=_LABELS,\n            kind=\"bar\",\n            order=df[_BITSTRINGS].unique().tolist(),\n            height=6,\n            aspect=1.5,\n            palette=cmap,\n        )\n\n    g.set_axis_labels(_BITSTRINGS, y_axis)\n\n    g.set_xticklabels(rotation=90)\n    return g\n</code></pre>"},{"location":"content/qubo_analyzer/#qubosolver.qubo_analyzer.QUBOAnalyzer.tensor_to_bitstrings","title":"<code>tensor_to_bitstrings(bitstring_tensor)</code>  <code>staticmethod</code>","text":"<p>Converts a torch tensor of bitstrings to a list of bitstring strings.</p> <p>Each row in the tensor is assumed to be a bitstring (with integer elements 0 or 1), and is converted to a single string (e.g., a row [0, 1, 0, 1, 0, 1] becomes \"010101\").</p> PARAMETER DESCRIPTION <code>bitstring_tensor</code> <p>Tensor of shape (num_bitstrings, bitstring_length)                              where each element is an integer (0 or 1).</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list[str]: A list of bitstring strings.</p> Source code in <code>qubosolver/qubo_analyzer.py</code> <pre><code>@staticmethod\ndef tensor_to_bitstrings(bitstring_tensor: torch.Tensor) -&gt; list[str]:\n    \"\"\"\n    Converts a torch tensor of bitstrings to a list of bitstring strings.\n\n    Each row in the tensor is assumed to be a bitstring (with integer elements 0 or 1),\n    and is converted to a single string (e.g., a row [0, 1, 0, 1, 0, 1] becomes \"010101\").\n\n    Args:\n        bitstring_tensor (torch.Tensor): Tensor of shape (num_bitstrings, bitstring_length)\n                                         where each element is an integer (0 or 1).\n\n    Returns:\n        list[str]: A list of bitstring strings.\n    \"\"\"\n    return [\"\".join(map(str, row.tolist())) for row in bitstring_tensor]\n</code></pre>"},{"location":"content/qubo_instance/","title":"Quadratic Unconstrained Binary Optimization","text":"<p>Solving combinatorial optimization (CO) problems using quantum computing is one of those promising applications for the near term. The Quadratic Unconstrained Binary Optimization (QUBO) (also known as unconstrained binary quadratic programming) <sup>1</sup> <sup>2</sup> model enables to formulate many CO problems that can be tackled using quantum hardware. QUBO offers a wide range of applications from finance and economics to machine learning.</p> <p>Given a QUBO problem made of \\(n\\) binary variables, its formulation is:</p> \\[\\min_{x \\in \\{0,1\\}^n} x^T Q x\\] <p>where \\(Q \\in \\mathbb{R}^{n \\times n}\\) is a matrix of coefficients (generally an upper triangular matrix).</p> <p>Expanding the formulation:</p> \\[\\min_{x \\in \\{0,1\\}^n} \\sum_{i=1}^{n} Q_{ii} x_i + \\sum_{i=1}^{n} \\sum_{j=i+1}^{n} Q_{ij} x_i x_j\\]"},{"location":"content/qubo_instance/#quboinstance","title":"QUBOInstance","text":"<p><code>QUBOInstance</code> represents a single Quadratic Unconstrained Binary Optimization (QUBO) problem. It encapsulates the QUBO matrix, solution, and relevant metrics of interest.</p>"},{"location":"content/qubo_instance/#features","title":"Features:","text":"<ul> <li>Store the QUBO coefficient matrix (<code>coefficients</code>).</li> <li>Evaluate solutions to compute their cost.</li> <li>Automatically compute metrics:</li> <li>Density: Fraction of non-zero elements in the matrix.</li> <li>Dynamically update the QUBO coefficients.</li> </ul>"},{"location":"content/qubo_instance/#code-example","title":"Code Example:","text":"<pre><code>from qubosolver import QUBOInstance\n\n# Define a QUBO coefficient matrix\ncoefficients = [[0, 1, 2], [1, 0, 3], [2, 3, 0]]\ninstance = QUBOInstance(coefficients=coefficients)\nprint(instance)\n\nsolution = [1, 0, 1]\ncost = instance.evaluate_solution(solution)\nprint(f\"\\nSolution Cost: {cost}\")\n\n# Save load\nfrom qubosolver.saveload import save_qubo_instance, load_qubo_instance\n\nsave_qubo_instance(instance, \"/tmp/qubo_instance.pt\")\nloaded_instance = load_qubo_instance(\"/tmp/qubo_instance.pt\")\nprint(f\"Loaded QUBOInstance: {loaded_instance}\")\n</code></pre>   'QUBOInstance of size = 3,density = 0.67,'  Solution Cost: 4.0 Loaded QUBOInstance: 'QUBOInstance of size = 3,density = 0.67,'"},{"location":"content/qubo_instance/#qubodataset","title":"QUBODataset","text":"<p><code>QUBODataset</code> represents a collection of QUBO problems. It is designed to store coefficients in a matrix, and solutions for multiple qubo problems, allowing for efficient batch operations and random dataset generation.</p>"},{"location":"content/qubo_instance/#features_1","title":"Features:","text":"<ul> <li>Store a batch of QUBO coefficient matrices (<code>coefficients</code>).</li> <li>Optionally include solutions for each instance.</li> <li>Generate datasets with random matrices, configurable by:<ul> <li>Size of the QUBO matrix.</li> <li>Density of non-zero elements.</li> <li>Value bounds range.</li> </ul> </li> <li>Access individual instances using indexing.</li> </ul>"},{"location":"content/qubo_instance/#code-example_1","title":"Code Example:","text":"<pre><code>from qubosolver.data import QUBODataset\n\n# Generate a random dataset\ndataset = QUBODataset.from_random(\n    n_matrices=5, matrix_dim=4, densities=[0.3, 0.7], coefficient_bounds=(-10, 10), device=\"cpu\"\n)\n\n# Access the first instance\ncoeffs, solution = dataset[0]\nprint(f\"Coefficients: {coeffs}\")\n# Get the dataset size\nprint(f\"\\nDataset size: {len(dataset)}\")\n\nfrom qubosolver.saveload import save_qubo_dataset, load_qubo_dataset\n\n# Save load\nsave_qubo_dataset(dataset, \"/tmp/qubo_dataset.pt\")\nloaded_dataset = load_qubo_dataset(\"/tmp/qubo_dataset.pt\")\nprint(f\"\\nLoaded QUBODataset size: {len(loaded_dataset)}\")\n</code></pre>   Coefficients: tensor([[-1.4509,  0.0000,  0.0000,  0.0000],         [ 0.0000, -0.0000, 10.0000,  0.0000],         [ 0.0000, 10.0000,  0.0000,  0.0000],         [ 0.0000,  0.0000,  0.0000,  5.1117]])  Dataset size: 10  Loaded QUBODataset size: 10"},{"location":"content/qubo_instance/#references","title":"References","text":"<ol> <li> <p>Glover et al., A Tutorial on Formulating and Using QUBO Models (2018) \u21a9</p> </li> <li> <p>Glover et al., Quantum bridge analytics I: a tutorial on formulating and using QUBO models (2022) \u21a9</p> </li> </ol>"},{"location":"content/solver/","title":"Solving a Quadratic Unconstrained Binary Optimization instance","text":"<p>Solving a QUBO instance is straightforward with <code>qubo-solver</code>. We can directly use the <code>QuboSolver</code> class by feeding instances of the <code>QUBOInstance</code> and <code>SolverConfig</code> classes. We can also specify whether to use a classical approach or a quantum one.</p>"},{"location":"content/solver/#solving-with-a-quantum-approach","title":"Solving with a quantum approach","text":"<p>To use a quantum approach, several choices have to be made regarging the configuration, explained in more details in the <code>SolverConfig</code> section. One main decision is about the backend, that is how we choose to perform quantum runs. We can decide to either perform our on emulators (locally, or remotely) or using a real quantum processing unit (QPU). Our QPU, based on the Rydberg Analog Model, is accessible remotely.</p>"},{"location":"content/solver/#available-backend-types-and-devices","title":"Available backend types and devices","text":"<p>The list of backend types available can be found via the <code>BackendType</code> enumeration from <code>Qooqit</code>, a Python package designed for algorithm development in the Rydberg Analog Model.</p> <pre><code>from qoolqit._solvers.types import BackendType\nall_backends = BackendType.list()\nprint('Local Backends: ', list(filter(lambda b: 'remote' not in b, all_backends)))\nprint('Remote Backends: ', list(filter(lambda b: 'remote' in b, all_backends)))\n</code></pre>   Local Backends:  ['qutip', 'emu_mps', 'emu_sv'] Remote Backends:  ['remote_qpu', 'remote_emumps', 'remote_emutn', 'remote_emufree']    <p>The backends can be divided into 3 main categories:</p> <ul> <li>Local emulators (Qutip, Emu_mps, Emu_sv, ...),</li> <li>Remote emulators, which can be accessed via <code>pasqal_cloud</code>,</li> <li>A remote QPU, such as Fresnel.</li> </ul> <p>For emulators, we use device specifications when performing quantum runs via <code>DeviceType</code>:</p> <pre><code>from qoolqit._solvers.types import DeviceType\nprint([e.value for e in DeviceType])\n</code></pre>   [AnalogDevice, DigitalAnalogDevice]"},{"location":"content/solver/#running-locally-with-an-emulator","title":"Running locally with an emulator","text":"<p>We can perform quantum simulations locally via an emulator (here, we choose the <code>BackendType.QUTIP</code> emulator).</p> <pre><code>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig\nfrom qubosolver.solver import QuboSolver\nfrom qoolqit._solvers.data import BackendConfig\nfrom qoolqit._solvers.types import BackendType\n\n# define QUBO\nQ = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\ninstance = QUBOInstance(coefficients=Q)\n\n# Create a SolverConfig object to use a quantum backend\nconfig = SolverConfig(use_quantum=True, backend_config = BackendConfig(backend=BackendType.QUTIP))\n\n# Instantiate the quantum solver.\nsolver = QuboSolver(instance, config)\n\n# Solve the QUBO problem.\nsolution = solver.solve()\n</code></pre>"},{"location":"content/solver/#running-with-a-remote-connection","title":"Running with a remote connection","text":"<p>We can decide to perform our runs remotely via <code>pasqal_cloud</code>. To do so, we have to provide several information after setting up an account.</p>"},{"location":"content/solver/#on-a-real-qpu","title":"On a real QPU","text":"<p>The code above can be modified to solve the QUBO instance using our real QPU remotely as follows:</p> <pre><code>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig\nfrom qubosolver.solver import QuboSolver\nfrom qoolqit._solvers.data import BackendConfig\nfrom qoolqit._solvers.types import BackendType, DeviceType\n\n# define QUBO\nQ = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\ninstance = QUBOInstance(coefficients=Q)\n\n# define a remote backend\nbackendconf = BackendConfig(backend=BackendType.REMOTE_QPU, username='#TO_PROVIDE', password='#TO_PROVIDE', project_id='#TO_PROVIDE')\n\n# Instantiate the quantum solver.\nsolver = QuboSolver(instance, backend_config=backendconf)\n\n# Solve the QUBO problem.\nsolution = solver.solve()\n</code></pre>"},{"location":"content/solver/#on-a-remote-emulators","title":"On a remote emulators","text":"<p>Emulators are also available remotely. Note that the default device set for remote connections is our QPU, but for emulators, you can specify a <code>DeviceType</code> as follows:</p> <pre><code>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig\nfrom qubosolver.solver import QuboSolver\nfrom qoolqit._solvers.data import BackendConfig\nfrom qoolqit._solvers.types import BackendType, DeviceType\n\n# define QUBO\nQ = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\ninstance = QUBOInstance(coefficients=Q)\n\n# define a remote backend\nbackendconf = BackendConfig(backend=BackendType.REMOTE_EMUFREE, device=DeviceType.DIGITAL_ANALOG_DEVICE, username='#TO_PROVIDE', password='#TO_PROVIDE', project_id='#TO_PROVIDE')\n\n# Instantiate the quantum solver.\nsolver = QuboSolver(instance, backend_config=backendconf)\n\n# Solve the QUBO problem.\nsolution = solver.solve()\n</code></pre>"},{"location":"content/solver/#solving-with-a-classical-approach","title":"Solving with a classical approach","text":"<p>We show below an example of solving a QUBO using CPLEX. More information on classical approaches can be found in the <code>Classical solvers</code> section of the <code>Contents</code> documentation.</p> <pre><code>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.config import ClassicalConfig, SolverConfig\nfrom qubosolver.solver import QuboSolverClassical, QuboSolverQuantum\n\n# define QUBO\nQ = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\ninstance = QUBOInstance(coefficients=Q)\n\n# Create a SolverConfig object with classical solver options.\nclassical_config = ClassicalConfig(\n    classical_solver_type=\"cplex\",\n    cplex_maxtime=10.0,\n    cplex_log_path=\"test_solver.log\",\n)\nconfig = SolverConfig(use_quantum=False, classical=classical_config)\n\n# Instantiate the classical solver via the pipeline's classical solver dispatcher.\nclassical_solver = QuboSolver(instance, config)\n\n# Solve the QUBO problem.\nsolution = classical_solver.solve()\n</code></pre>"},{"location":"content/utilities/","title":"Utilities","text":""},{"location":"content/utilities/#utilities","title":"Utilities","text":"<p>Utilities provide helper functions to calculate and classify key metrics, as well as to save and load QUBO instances and datasets.</p>"},{"location":"content/utilities/#density","title":"Density","text":"<ul> <li>Calculate Density: Compute the fraction of non-zero elements in the QUBO matrix.</li> <li>Classify Density: Categorize density as SPARSE, MEDIUM, or HIGH.</li> </ul> <pre><code>from qubosolver.utils.density import calculate_density, classify_density\n\ncoefficients = torch.tensor([[0, 1, -2], [1, 0, 3], [-2, 3, 0]])\nsize = 3\n\n# Calculate density\ndensity = calculate_density(coefficients, size)\n\n# Classify density\ndensity_type = classify_density(density)\n\nprint(f\"Density: {density}, Classified as: {density_type}\")\n</code></pre>"},{"location":"content/utilities/#save-and-load","title":"Save and Load","text":"<ul> <li>Save a QUBOInstance: Save a <code>QUBOInstance</code> to a file.</li> <li>Load a QUBOInstance: Load a <code>QUBOInstance</code> from a file.</li> <li>Save a QUBODataset: Save a <code>QUBODataset</code> to a file.</li> <li>Load a QUBODataset: Load a <code>QUBODataset</code> from a file.</li> </ul> <p><pre><code>from qubosolver.utils import save_qubo_instance, load_qubo_instance\nfrom qubosolver import QUBOInstance\n\n# Define a QUBO coefficient matrix\ncoefficients = [[0, 1, -2], [1, 0, 3], [-2, 3, 0]]\ninstance = QUBOInstance(coefficients=coefficients)\n\n# Save and load a QUBOInstance\nsave_qubo_instance(instance, \"qubo_instance.pt\")\nloaded_instance = load_qubo_instance(\"qubo_instance.pt\")\nprint(loaded_instance)\n</code></pre> <pre><code>from qubosolver import QUBODataset\nfrom qubosolver.utils import save_qubo_dataset, load_qubo_dataset\n\ndataset = QUBODataset.from_random(n=5, size=4, densities=[0.3, 0.7], coefficient_bounds=(-10,10), device=\"cpu\")\n\n# Save and load a QUBODataset\nsave_qubo_dataset(dataset, \"qubo_dataset.pt\")\nloaded_dataset = load_qubo_dataset(\"qubo_dataset.pt\")\nprint(f\"Loaded dataset size: {len(loaded_dataset)}\")\n</code></pre></p>"},{"location":"content/classical/cplex_solver/cplex_solving/","title":"<code>CplexSolver</code> Class Documentation","text":""},{"location":"content/classical/cplex_solver/cplex_solving/#overview","title":"Overview","text":"<p>The <code>CplexSolver</code> class implements a classical QUBO solver using IBM ILOG CPLEX. It extends the <code>BaseClassicalSolver</code> abstract base class and translates a QUBO (Quadratic Unconstrained Binary Optimization) instance into a CPLEX quadratic optimization model.</p>"},{"location":"content/classical/cplex_solver/cplex_solving/#initialization","title":"Initialization","text":"<pre><code>class CplexSolver(BaseClassicalSolver):\n    def __init__(\n        self,\n        instance: QUBOInstance,\n        config: Optional[Dict[str, Any]] = None\n    )\n</code></pre> <ul> <li>Parameters:</li> <li><code>instance</code> (<code>QUBOInstance</code>): QUBO problem containing a square coefficient matrix (<code>torch.Tensor</code>).</li> <li><code>config</code> (<code>Optional[Dict[str, Any]]</code>): Dictionary supporting:<ul> <li><code>cplex_maxtime</code> (<code>float</code>, default <code>600.0</code>): Maximum solve time in seconds.</li> <li><code>cplex_log_path</code> (<code>str</code>, default <code>\"solver.log\"</code>): Path for CPLEX log output.</li> </ul> </li> </ul>"},{"location":"content/classical/cplex_solver/cplex_solving/#configuration-options","title":"Configuration Options","text":"Key Type Default Description <code>cplex_maxtime</code> <code>float</code> <code>600.0</code> Time limit for the CPLEX solver, in seconds. <code>cplex_log_path</code> <code>str</code> <code>\"solver.log\"</code> Log file path for CPLEX output streams. <p>Configure the solver by passing a dict at instantiation:</p> <pre><code>config = {\n    \"cplex_maxtime\": 300.0,\n    \"cplex_log_path\": \"cplex_run.log\",\n}\nsolver = CplexSolver(qubo_instance, config)\n</code></pre>"},{"location":"content/classical/cplex_solver/cplex_solving/#solve-method","title":"<code>solve()</code> Method","text":"<pre><code>def solve(self) -&gt; QUBOSolution\n</code></pre> <p>Solves the QUBO problem via CPLEX and returns a <code>QUBOSolution</code> containing bitstrings and costs.</p>"},{"location":"content/classical/cplex_solver/cplex_solving/#behavior","title":"Behavior","text":"<ol> <li> <p>Validate Input    Raises <code>ValueError</code> if <code>instance.coefficients</code> is <code>None</code>.</p> </li> <li> <p>Handle Empty Problem    If the coefficient matrix has size zero, returns an empty <code>QUBOSolution</code>.</p> </li> <li> <p>Convert to Sparse Format    Calls <code>qubo_instance_to_sparsepairs(instance)</code> to obtain <code>List[cplex.SparsePair]</code> for quadratic terms.</p> </li> <li> <p>Build CPLEX Model</p> </li> <li>Instantiate <code>cplex.Cplex()</code>.</li> <li>Redirect log, error, warning, and result streams to the file at <code>cplex_log_path</code>.</li> <li>Set <code>timelimit</code> parameter to <code>cplex_maxtime</code>.</li> <li>Specify minimization objective.</li> <li>Add <code>N</code> binary variables (<code>types=\"B\" * N</code>).</li> <li> <p>Assign quadratic objective via <code>objective.set_quadratic(sparsepairs)</code>.</p> </li> <li> <p>Solve    Invoke <code>problem.solve()</code>.</p> </li> <li> <p>Extract Results</p> </li> <li>Retrieve variable values (<code>problem.solution.get_values()</code>) and objective cost (<code>get_objective_value()</code>).</li> <li> <p>Close the log file.</p> </li> <li> <p>Format Output</p> </li> <li>Build a <code>torch.Tensor</code> for bitstrings of shape <code>(1, N)</code>, dtype <code>float32</code>.</li> <li>Build a <code>torch.Tensor</code> for cost of shape <code>(1,)</code>, dtype <code>float32</code>.</li> <li>Return <code>QUBOSolution(bitstrings, costs)</code>.</li> </ol>"},{"location":"content/classical/cplex_solver/cplex_solving/#exceptions","title":"Exceptions","text":"<ul> <li><code>ValueError</code>: Thrown if the QUBO instance has no coefficients.</li> </ul>"},{"location":"content/classical/cplex_solver/cplex_solving/#example-usage","title":"Example Usage","text":"<pre><code>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig, ClassicalConfig\nfrom qubosolver.solver import QuboSolver\n\n# Define a simple 2\u00d72 QUBO matrix (identity)\nmatrix = torch.eye(2)\ninstance = QUBOInstance(coefficients=matrix)\n\n# Prepare solver configuration\ncplex = ClassicalConfig(\n    classical_solver_type=\"cplex\",\n    cplex_maxtime=120.0,\n    cplex_log_path=\"cplex_run.log\",\n)\nconfig = SolverConfig(\n    classical=cplex,\n    use_quantum=False\n)\n\n# Directly obtain solution via dispatcher\nclassical_solver = QuboSolver(instance, config)\nsolution = classical_solver.solve()\n\nprint(\"Bitstrings:\", solution.bitstrings)\nprint(\"Costs:\", solution.costs)\n</code></pre>   Bitstrings: tensor([[0, 0]]) Costs: tensor([0.])"},{"location":"content/classical/heuristics/simulatedannealing/","title":"Simulated Annealing","text":""},{"location":"content/classical/heuristics/simulatedannealing/#dwavesasolver","title":"<code>DwaveSASolver</code>","text":"<p>Simple classical solver class using Simulated Annealing. Designed to integrate with the solver factory.</p>"},{"location":"content/classical/heuristics/simulatedannealing/#signature","title":"Signature","text":"<pre><code>class DwaveSASolver(BaseClassicalSolver):\n    def solve(self) -&gt; QUBOSolution\n</code></pre>"},{"location":"content/classical/heuristics/simulatedannealing/#description","title":"Description","text":"<p>This solver uses a Simulated Annealing backend to probabilistically explore the solution space. It is suitable for approximating solutions on medium-sized QUBO instances. Computation is entirely classical and based on the <code>SimulatedAnnealingSampler</code> from DWave's Ocean SDK [add the ref below ?]. The output is fully compatible with the <code>QUBOSolution</code> structure used in the <code>qubo-solver</code> package.</p>"},{"location":"content/classical/heuristics/simulatedannealing/#fields","title":"Fields","text":"Field Type Description <code>use_quantum</code> <code>bool</code> Have to be <code>False</code> to uses a classical solver. <code>classical_solver_type</code> <code>str</code> Set to <code>\"dwave_sa\"</code> to use Simulated Annealing as the solving method."},{"location":"content/classical/heuristics/simulatedannealing/#usage","title":"Usage","text":"<pre><code>from qubosolver import QUBOInstance\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.config import SolverConfig, ClassicalConfig\n\nqubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]])\nconfig = SolverConfig(use_quantum = False, classical=ClassicalConfig(classical_solver_type=\"dwave_sa\"))\n\nsolver = QuboSolver(qubo, config)\n\nsolution = solver.solve()\nprint(solution)\n</code></pre>   QUBOSolution(bitstrings=tensor([[1., 1.]]), costs=tensor([-2.]), counts=None, probabilities=None, solution_status=)"},{"location":"content/classical/heuristics/simulatedannealing/#notes","title":"Notes","text":"<p>Recommended for local, classical solving when exact optimization is not required.</p>"},{"location":"content/classical/heuristics/simulatedannealing/#references","title":"References","text":"<ul> <li>D-Wave Systems Inc., Ocean SDK \u2014 SimulatedAnnealingSampler doc</li> </ul>"},{"location":"content/classical/heuristics/tabu/","title":"Tabu Search","text":""},{"location":"content/classical/heuristics/tabu/#dwavetabusolver","title":"<code>DwaveTabuSolver</code>","text":"<p>Classical solver using Tabu Search. Designed to integrate with the solver factory.</p>"},{"location":"content/classical/heuristics/tabu/#signature","title":"Signature","text":"<pre><code>class DwaveTabuSolver(BaseClassicalSolver):\n    def solve(self) -&gt; QUBOSolution\n</code></pre>"},{"location":"content/classical/heuristics/tabu/#description","title":"Description","text":"<p>This solver applies a Tabu Search metaheuristic to escape local minima and explore the solution space. It is suitable for solving QUBO instances classically without relying on quantum hardware. The implementation is based on <code>TabuSampler</code> from the Ocean SDK, and returns solutions compatible with the <code>QUBOSolution</code> interface used across the <code>qubo-solver</code> package.</p>"},{"location":"content/classical/heuristics/tabu/#fields","title":"Fields","text":"Field Type Description <code>use_quantum</code> <code>bool</code> Have to be <code>False</code> to uses a classical solver. <code>classical_solver_type</code> <code>str</code> Set to <code>\"dwave_tabu\"</code> to use Tabu Search as the solving method."},{"location":"content/classical/heuristics/tabu/#usage","title":"Usage","text":"<pre><code>from qubosolver import QUBOInstance\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.config import SolverConfig, ClassicalConfig\n\nqubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]])\nconfig = SolverConfig(use_quantum = False, classical=ClassicalConfig(classical_solver_type=\"dwave_tabu\"))\n\nsolver = QuboSolver(qubo, config)\n\nsolution = solver.solve()\nprint(solution)\n</code></pre>   QUBOSolution(bitstrings=tensor([[1., 1.]]), costs=tensor([-2.]), counts=None, probabilities=None, solution_status=)"},{"location":"content/classical/heuristics/tabu/#notes","title":"Notes","text":"<p>Recommended for classical heuristics when reproducibility and control over local search dynamics are desired.</p>"},{"location":"content/classical/heuristics/tabu/#references","title":"References","text":"<ul> <li>D-Wave Systems Inc., Ocean SDK \u2014 TabuSampler doc</li> </ul>"},{"location":"content/classical/post-and-pre_processing/postprocessing/","title":"<code>postprocess</code> Method Documentation","text":""},{"location":"content/classical/post-and-pre_processing/postprocessing/#overview","title":"Overview","text":"<p>The <code>postprocess</code> method of the <code>Fixtures</code> class refines raw QUBO solutions by applying a local bit-flip search to each candidate bitstring. It evaluates each modified solution against the original QUBO instance, aiming to lower the objective cost.</p>"},{"location":"content/classical/post-and-pre_processing/postprocessing/#method-signature","title":"Method Signature","text":"<pre><code>def postprocess(self, solution: QUBOSolution) -&gt; QUBOSolution\n</code></pre>"},{"location":"content/classical/post-and-pre_processing/postprocessing/#parameters","title":"Parameters","text":"<ul> <li><code>solution</code> (<code>QUBOSolution</code>): The QUBO solver's output, containing:</li> <li><code>bitstrings</code>: Tensor of shape <code>(num_samples, num_variables)</code> representing candidate solutions.</li> <li><code>costs</code>: Tensor of shape <code>(num_samples,)</code> with corresponding objective values.</li> <li>Optional <code>counts</code> and <code>probabilities</code> attributes.</li> </ul>"},{"location":"content/classical/post-and-pre_processing/postprocessing/#returns","title":"Returns","text":"<ul> <li><code>QUBOSolution</code>: A new solution object where each bitstring has been locally optimized and costs recomputed. It includes:</li> <li>Updated <code>bitstrings</code> (dtype <code>float32</code>) of shape <code>(num_samples, num_variables)</code>.</li> <li>Updated <code>costs</code> (dtype <code>float32</code>) of shape <code>(num_samples,)</code>.</li> <li><code>solution_status</code>: A description indicating postprocessing and listing the improved costs.</li> <li>Preserved <code>counts</code> and <code>probabilities</code> if originally present.</li> </ul>"},{"location":"content/classical/post-and-pre_processing/postprocessing/#behavior","title":"Behavior","text":"<ol> <li> <p>No-op for Empty Solutions    If <code>solution.bitstrings</code> is empty, the method returns the input <code>solution</code> unchanged.</p> </li> <li> <p>Objective Wrapper    Defines an inner function:    <pre><code>def qubo_objective(s_arr: np.ndarray) -&gt; float:\n    return self.instance.evaluate_solution(s_arr.tolist())\n</code></pre>    to compute the cost of any candidate bitstring via the original QUBO instance.</p> </li> <li> <p>Local Bit-Flip Search    For each bitstring in <code>solution.bitstrings</code>:</p> </li> <li>Convert the tensor row to a NumPy integer array.</li> <li>Call <code>bit_flip_local_search(qubo_objective, s_orig)</code> to greedily flip bits and reduce cost.</li> <li> <p>Collect the improved bitstring and its new cost.</p> </li> <li> <p>Assemble Tensors    Stack all improved bitstrings and costs into new PyTorch tensors (<code>dtype=torch.float32</code>).</p> </li> <li> <p>Update and Return</p> </li> <li>Replace <code>solution.bitstrings</code> and <code>solution.costs</code> with the improved tensors.</li> <li>Set <code>solution.solution_status</code> to:      <pre><code>postprocessed (improved costs: [c1, c2, \u2026])\n</code></pre></li> <li>Return the modified <code>QUBOSolution</code>.</li> </ol>"},{"location":"content/classical/post-and-pre_processing/postprocessing/#example-usage-with-fixtures","title":"Example Usage with <code>Fixtures</code>","text":"<pre><code>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig, ClassicalConfig\nfrom qubosolver.pipeline import Fixtures\nfrom qubosolver.solver import QuboSolver\n\n# Create a random 4-variable QUBO instance\ngraphics = torch.randn(4, 4)\ngraphics = (graphics + graphics.T) / 2  # Ensure symmetry\nn = graphics.size(0)\noff_diag_mask = ~torch.eye(n, dtype=torch.bool)\ngraphics[off_diag_mask] = graphics[off_diag_mask].abs() # Ensure Abs off-diagonal\nqubo = QUBOInstance(coefficients=graphics)\n\n# Configure solver to enable postprocessing\ncplex = ClassicalConfig(classical_solver_type=\"cplex\", cplex_log_path=\"solver.log\", cplex_maxtime=300.0,)\nconfig = SolverConfig(\n    use_quantum=False,\n    classical=cplex,\n    do_postprocessing=True\n)\n\n# Solve with classical solver\nclassical_solver = QuboSolver(qubo, config)\nraw_solution = classical_solver.solve()\n\n# Apply postprocessing\nfixture = Fixtures(qubo, config)\nfinal_solution = fixture.postprocess(raw_solution)\n\nprint(\"Optimized bitstrings:\", final_solution.bitstrings)\nprint(\"Optimized costs:\", final_solution.costs)\nprint(\"Status:\", final_solution.solution_status)\n</code></pre>   Optimized bitstrings: tensor([[0., 1., 1., 0.]]) Optimized costs: tensor([-1.9089]) Status: postprocessed"},{"location":"content/classical/post-and-pre_processing/postprocessing/#example-usage-without-direct-fixture-manipulation","title":"Example Usage without Direct Fixture Manipulation","text":"<p>Instead of manually instantiating <code>Fixtures</code>, you can enable postprocessing directly through your solver configuration:</p> <pre><code>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig, ClassicalConfig\nfrom qubosolver.solver import QuboSolver\nimport emu_mps\nfrom qoolqit._solvers.types import BackendType\n\n\n# Assume `first_qubo_coefficients` is your 2\u00d72 QUBO matrix (e.g., identity):\nfirst_qubo_coefficients = torch.eye(2)\ninstance = QUBOInstance(coefficients=first_qubo_coefficients)\n\n# Configure solver with postprocessing enabled\ncplex = ClassicalConfig(classical_solver_type=\"cplex\", cplex_log_path=\"solver.log\", cplex_maxtime=300.0,)\nconfig = SolverConfig(\n    classical=cplex,\n    do_postprocessing=True,                  # Enable postprocessing\n    use_quantum=False\n)\n\n# Instantiate and run the classical solver\nclassical_solver = QuboSolver(instance, config)\nsolution = classical_solver.solve()\n\nprint(\"Final bitstrings:\", solution.bitstrings)\nprint(\"Final costs:\", solution.costs)\nprint(\"Status:\", solution.solution_status)\n</code></pre>   Final bitstrings: tensor([[0, 0]]) Final costs: tensor([0.]) Status: trivial-zero"},{"location":"content/classical/post-and-pre_processing/preprocessing/","title":"Pre-processing","text":""},{"location":"content/classical/post-and-pre_processing/preprocessing/#qubo-preprocessing","title":"QUBO Preprocessing","text":"<p>QUBO preprocessing is an optional step that attempts to reduce the size of the problem before solving, by deterministically fixing variables to 0 or 1 when possible.</p>"},{"location":"content/classical/post-and-pre_processing/preprocessing/#activation","title":"Activation","text":"<p>Preprocessing is enabled by setting <code>do_preprocessing=True</code> in the solver configuration (<code>SolverConfig</code>). No additional setup is required. This mechanism is supported by all solvers.</p>"},{"location":"content/classical/post-and-pre_processing/preprocessing/#method","title":"Method","text":"<p>Two deterministic rules are applied iteratively until no further variables can be fixed:</p> <ul> <li> <p>Hansen Fixing Rule   A rule based on the diagonal and off-diagonal entries of the QUBO matrix. It fixes variables whose contribution to the objective function can be bounded independently of the rest of the problem.</p> </li> <li> <p>Roof Duality   A technique based on duality theory that provides provably optimal variable fixations. It is implemented using the <code>roof_duality</code> function from the D-Wave Ocean SDK.</p> </li> </ul> <p>These rules are applied in sequence until convergence, reducing the QUBO instance before it is passed to the solver.</p>"},{"location":"content/classical/post-and-pre_processing/preprocessing/#fixation-restoration","title":"Fixation Restoration","text":"<p>After solving the reduced QUBO, fixed variables are automatically reinserted into the solution bitstrings to restore their original size and order.</p>"},{"location":"content/classical/post-and-pre_processing/preprocessing/#fields","title":"Fields","text":"Field Type Description <code>do_preprocessing</code> <code>bool</code> If <code>True</code>, activates preprocessing before solving. The solver will attempt to fix variables and reduce the QUBO size."},{"location":"content/classical/post-and-pre_processing/preprocessing/#example","title":"Example","text":"<pre><code>from qubosolver import QUBOInstance\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.config import SolverConfig, ClassicalConfig\n\nqubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]])\n\n# Create a SolverConfig object with classical solver options.\nconfig = SolverConfig(\n    use_quantum=False,\n    classical=ClassicalConfig(classical_solver_type=\"dwave_tabu\"),\n    do_preprocessing=True\n)\n\nsolver = QuboSolver(qubo, config)\nsolution = solver.solve()\nprint(solution)\n</code></pre>   QUBOSolution(bitstrings=tensor([[1., 1.]]), costs=tensor([-2.]), counts=None, probabilities=None, solution_status=)"},{"location":"content/classical/post-and-pre_processing/preprocessing/#notes","title":"Notes","text":"<ul> <li>Preprocessing does not introduce approximation or randomness. All variable fixations are guaranteed to be optimal with respect to the original QUBO.</li> <li>This step is particularly effective for sparse or structured QUBO matrices, where many variables can often be fixed early.</li> </ul>"},{"location":"content/classical/post-and-pre_processing/preprocessing/#references","title":"References","text":"<ul> <li>Hansen, P. (1979). Method of non-linear 0-1 programming. Annals of Discrete Mathematics, 5:53\u201370.</li> <li>D-Wave Systems Inc., Ocean SDK \u2014 dwave.preprocessing.roof_duality doc</li> </ul>"},{"location":"content/pulseshaping/adiabatic/","title":"Adiabatic Pulse","text":""},{"location":"content/pulseshaping/adiabatic/#adiabatic-pulse-shaper","title":"Adiabatic Pulse Shaper","text":"<p><code>AdiabaticPulseShaper</code> is a class for implementing a standard adiabatic pulse shaping method. It creates an <code>InterpolatedWaveform</code> pulse for solving a <code>QUBOInstance</code> using adiabatic quantum evolution, There are no parameters to be customized.</p>"},{"location":"content/pulseshaping/adiabatic/#how-it-works","title":"How it works:","text":"<ul> <li>Creates a normalized weights list for the later application of DMM.</li> <li>Computes the maximum amplitude value.</li> <li>Computes the global detuning values (initial and final).</li> <li>Creates a pulse with the values of amplitude, detuning and duration (4000 ns).</li> </ul>"},{"location":"content/pulseshaping/adiabatic/#fields","title":"Fields","text":"Field Type Description <code>pulse</code> <code>Pulse</code> A Pulser-compatible pulse object generated by <code>generate()</code>."},{"location":"content/pulseshaping/adiabatic/#methods","title":"Methods","text":"<p><code>generate(register: Register, instance: QUBOInstance) -&gt; tuple[Pulse, QUBOSolution]</code> Generates a shaped adiabatic pulse for the given QUBO problem and register layout.</p> Argument Type Description <code>register</code> <code>Register</code> The spatial layout of qubits/atoms in the physical system. <code>instance</code> <code>QUBOInstance</code> The QUBO matrix of the problem."},{"location":"content/pulseshaping/adiabatic/#returns","title":"Returns","text":"Type Description <code>tuple[Pulse, QUBOSolution]</code> Returns the generated <code>Pulse</code> object and a placeholder <code>QUBOSolution</code> (with all fields set to <code>None</code>)"},{"location":"content/pulseshaping/adiabatic/#notes","title":"Notes","text":"<p>The method sets:</p> <ul> <li> <p><code>pulse.norm_weights</code>: A normalized weight per node, used for DMM.</p> </li> <li> <p><code>pulse.duration</code>: Total evolution time (fixed at <code>T = 4000</code> ns by default).</p> </li> </ul>"},{"location":"content/pulseshaping/adiabatic/#definition-of-amplitude-and-detuning","title":"Definition of Amplitude and Detuning:","text":"<p>For the Adiabatic Pulse, the values of the amplitude \\(\\Omega\\) (Rabi frequency) and global detuning \\(\\delta\\) are defined in terms of the <code>QUBOInstance</code>, as follows:</p> <ul> <li>Amplitude: has a sine-like shape, starting from \\(0\\) and ending in \\(0\\), with a maximum value being the maximum value among the off-diagonal terms of the QUBO matrix:</li> </ul> \\[\\Omega_{max} = max(Q_{off})\\] <p>If \\(\\Omega_{max}\\) reaches a value above the maximum amplitude allowed by the device, it uses this <code>max_amp</code> as \\(\\Omega_{max}\\).</p> <ul> <li>Detuning: starts from a negative value \\(\\delta_0\\) that is the minimum value among the diagonal terms of the QUBO matrix (since diagonal terms are either negative or \\(0\\)), reaches \\(0\\) and ends in a positive final value \\(\\delta_f\\), following a linear behavior:</li> </ul> \\[\\delta_0 = min(Q_{diag})\\] \\[\\delta_f = -\\delta_0\\]"},{"location":"content/pulseshaping/adiabatic/#application-of-dmm","title":"Application of DMM","text":"<p>Along with the pulse created with the amplitude and detuning values, the detuning of individual qubits (defined as list of values between 0 and 1) is applied using a channel called Detuning Map Modulator or <code>DMM</code>. Proportionally to the weights of each qubit, a pulse of zero amplitude and negative detuning is applied. Here, the values of the detuning are normalized in terms of the maximum absolute value of the diagonal terms and subtracted from 1. For each qubit \\(i\\) the value is:</p> \\[DMM = 1 - (w_i/w_{max}) \\] <p>This way, the qubits with lower weights receive higher detuning values, whilst the ones with higher weights receive lower values.</p>"},{"location":"content/pulseshaping/adiabatic/#example","title":"Example","text":"<p><pre><code>import torch\n\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig, PulseShapingConfig\nfrom qoolqit._solvers.types import BackendType, DeviceType\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.qubo_types import PulseType\n\n\nQ = torch.tensor([\n    [-63.9423,   0.0000,  73.6471,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,  55.2853],\n    [  0.0000, -44.1916,   0.0000,   0.0000,   0.0000,   0.0000,  58.9307,   0.0000,   0.0000,   0.0000],\n    [ 73.6471,   0.0000, -89.8861,  51.0382,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000],\n    [  0.0000,   0.0000,  51.0382, -63.7618,   0.0000,   0.0000,  33.9093,   0.0000,   0.0000,   0.0000],\n    [  0.0000,   0.0000,   0.0000,   0.0000, -94.4426,  18.7963,   0.0000,   0.0000,  14.3994,   0.0000],\n    [  0.0000,   0.0000,   0.0000,   0.0000,  18.7963, -60.7545,   0.0000,   0.0000,   0.0000,  96.9903],\n    [  0.0000,  58.9307,   0.0000,  33.9093,   0.0000,   0.0000, -71.3241,   0.0000,   0.0000,   0.0000],\n    [  0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000, -38.2094,  59.3175,   0.0000],\n    [  0.0000,   0.0000,   0.0000,   0.0000,  14.3994,   0.0000,   0.0000,  59.3175, -94.5790,  18.0653],\n    [ 55.2853,   0.0000,   0.0000,   0.0000,   0.0000,  96.9903,   0.0000,   0.0000,  18.0653, -97.3174]\n])\n\ninstance = QUBOInstance(Q)\n\ndefault_config = SolverConfig(\n    use_quantum = True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.ADIABATIC)\n)\nsolver = QuboSolver(instance, default_config)\n\nsolution = solver.solve()\nprint(solution)\n</code></pre>   QUBOSolution(bitstrings=tensor([[0., 1., 1., 0., 0., 0., 0., 0., 0., 1.],         [0., 1., 0., 1., 1., 0., 0., 0., 0., 0.],         [1., 1., 0., 1., 0., 0., 0., 0., 0., 0.],         [0., 0., 1., 1., 0., 1., 0., 0., 0., 0.],         [0., 1., 1., 1., 0., 0., 0., 0., 0., 0.],         [0., 0., 1., 1., 0., 0., 0., 1., 0., 0.],         [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]), costs=tensor([-231.3951, -202.3960, -171.8957, -112.3260,  -95.7631,  -89.7809,          242.3500]), counts=tensor([  2,   2,   1,   2, 304,   1, 188], dtype=torch.int32), probabilities=tensor([0.0040, 0.0040, 0.0020, 0.0040, 0.6080, 0.0020, 0.3760]), solution_status=)    This will return a <code>QUBOSolution</code> instance, which comprehends the solution bitstrings, the counts of each bitstring, their probabilities and costs. <p>Obs.: The <code>ADIABATIC</code> method is the default one, it's explicit in <code>pulse_shaping_method</code> for ilustration purposes.</p>"},{"location":"content/pulseshaping/custom/","title":"Custom","text":""},{"location":"content/pulseshaping/custom/#custom-pulse-shaper-config","title":"Custom Pulse Shaper config","text":"<p>If one desires to develop his own pulse shaping method, a subclass of <code>qubosolver.pipeline.pulse.BasePulseShaper</code> should be implemented with a mandatory <code>generate</code> method.</p> <p>The <code>generate</code> method syntax is <code>generate(register: Register, instance: QUBOInstance) -&gt; tuple[Pulse, QUBOSolution]</code>  with arguments: - a <code>Register</code> instance specifying the qubits we work with. - a <code>QUBOInstance</code> specifying the qubo problem we target.</p> <p>It returns: - an instance of <code>Pulse</code> - a <code>QUBOSolution</code> specyfing the solution that may be used by a solver.</p> <p>For concrete examples, we have the <code>AdiabaticPulseShaper</code> and the <code>OptimizedPulseShaper</code> and their current implementations lie in <code>qubosolver.pipeline.pulse.py</code>.</p> <p>Let us show an example of Adiabatic pulse shaper but with a duration divided by 20.</p> <pre><code>import typing\nfrom qubosolver.pipeline.pulse import BasePulseShaper\nfrom qubosolver.solver import QUBOInstance\nfrom qubosolver.data import QUBOSolution\nfrom qubosolver.pipeline.targets import Register as TargetRegister\nfrom qubosolver.config import (\n    PulseShapingConfig,\n    SolverConfig,\n)\nfrom qubosolver.pipeline.targets import Pulse, Register\n\nfrom pulser import Pulse as PulserPulse\nfrom pulser.devices import DigitalAnalogDevice\nfrom pulser.waveforms import InterpolatedWaveform\n\nclass LimitedAdiabaticPulseShaper(BasePulseShaper):\n\n    def generate(\n        self,\n        register: Register,\n        instance: QUBOInstance,\n    ) -&gt; tuple[Pulse, QUBOSolution]:\n\n        QUBO = instance.coefficients\n        weights_list = torch.abs(torch.diag(QUBO)).tolist()\n        max_node_weight = max(weights_list)\n        norm_weights_list = [1 - (w / max_node_weight) for w in weights_list]\n\n        T = 4000\n        off_diag = QUBO[\n            ~torch.eye(QUBO.shape[0], dtype=bool)\n        ]  # Selecting off-diagonal terms of the Qubo with a mask\n        Omega = min(\n            torch.max(off_diag).item(),\n            DigitalAnalogDevice.channels[\"rydberg_global\"].max_amp - 1e-9,\n        )\n\n        delta_0 = torch.min(torch.diag(QUBO)).item()\n        delta_f = -delta_0\n\n        amp_wave = InterpolatedWaveform(T // 20, [1e-9, Omega, 1e-9])\n        det_wave = InterpolatedWaveform(T // 20, [delta_0, 0, delta_f])\n\n        pulser_pulse = PulserPulse(amp_wave, det_wave, 0)\n\n        shaped_pulse = Pulse(pulse=pulser_pulse)\n        shaped_pulse.norm_weights = norm_weights_list\n        shaped_pulse.duration = T\n\n        self.pulse = shaped_pulse\n        solution = QUBOSolution(None, None)\n\n        return self.pulse, solution\n\n\nconfig = SolverConfig(\n    use_quantum=True,\n    pulse_shaping=PulseShapingConfig(pulse_shaping_method=LimitedAdiabaticPulseShaper),\n)\n</code></pre>"},{"location":"content/pulseshaping/optimized/","title":"Optimized Pulse","text":""},{"location":"content/pulseshaping/optimized/#optimized-pulse-shaper","title":"Optimized Pulse Shaper","text":"<p><code>OptimizedPulseShaper</code> uses bayesian optimization to find pulse parameters (amplitude and detuning) in order to solve a QUBO problem using quantum simulation.</p> <p>It outputs both the optimized pulse and a solution object containing bitstrings, counts, probabilities, and associated costs.</p>"},{"location":"content/pulseshaping/optimized/#features","title":"Features:","text":"<ul> <li>Computes normalized weights from the QUBO diagonal to support later application of the Detuning Map Modulator (DMM).</li> <li>Uses Bayesian optimization to tune six parameters: three for the Rabi amplitude (\\(\\Omega\\)), and three for the global detuning (\\(\\delta\\)).</li> <li>Executes quantum simulations at each iteration to evaluate candidate pulse parameters and their performance on the QUBO.</li> <li>Returns the final optimized pulse and best QUBO solution, with full metadata (counts, probabilities, and costs).</li> </ul>"},{"location":"content/pulseshaping/optimized/#initialization-parameters","title":"Initialization Parameters:","text":"Field Type Description <code>instance</code> <code>QUBOInstance</code> Qubo instance. <code>config</code> <code>SolverConfig</code> Configuration for solving."},{"location":"content/pulseshaping/optimized/#pulse-parameterization","title":"Pulse Parameterization","text":"<p>The optimized pulse is built from an <code>InterpolatedWaveform</code> with:</p> <p>Amplitude: \\(\\Omega = [0, \\Omega_1, \\Omega_2, \\Omega_3, 0]\\)</p> <p>Detuning: \\(\\delta = [\\delta_1, \\delta_2, \\delta_3]\\)</p> <p>These waveforms:</p> <p>Always start and end in zero amplitude; Use 3 intermediate amplitude values (\\(\\Omega_1\\) to \\(\\Omega_3\\)) and 3 detuning values (\\(\\delta_1\\) to \\(\\delta_3\\)), which are the parameters optimized.</p> <p>The pulse starts with an <code>InterpolatedWaveform</code> with the points:</p> <ul> <li>\\(\\Omega = [0, 5, 10, 5, 0]\\)</li> <li>\\(\\delta = [-10, 0, 10]\\)</li> </ul>"},{"location":"content/pulseshaping/optimized/#methods-overview","title":"Methods Overview","text":"<ul> <li> <p><code>generate(self, target: Register, instance: QUBOInstance) -&gt; tuple[Pulse, QUBOSolution]</code>: Runs the Bayesian optimization loop and returns the optimized pulse and corresponding solution. Handles fallback cases if simulation fails.</p> </li> <li> <p><code>build_pulse(self, params: list) -&gt; Pulse</code>: Creates a Pulse from a 6-element parameter list: the first 3 for amplitude, the last 3 for detuning.</p> </li> <li> <p><code>_compute_norm_weights(self, QUBO: torch.Tensor) -&gt; list[float]</code>: Normalizes the QUBO diagonal weights (used in DMM shaping).</p> </li> <li> <p><code>run_simulation(...) -&gt; tuple[...]</code>: Runs a simulation of the current pulse on a quantum backend and returns bitstring results, probabilities, and QUBO costs.</p> </li> <li> <p><code>compute_qubo_cost(self, bitstring: str, QUBO: torch.Tensor) -&gt; float</code>: Computes the QUBO cost of a specific bitstring.</p> </li> </ul>"},{"location":"content/pulseshaping/optimized/#output-structure","title":"Output Structure","text":"<p>After the final round of optimization, the following attributes are populated:</p> <ul> <li><code>pulse</code>: Final Pulse object with optimized waveform parameters.</li> <li><code>best_cost</code>: Minimum cost found during optimization.</li> <li><code>best_bitstring</code>: Corresponding bitstring with the lowest cost.</li> <li><code>bitstrings, counts, probabilities, costs</code>: Full result distributions as PyTorch tensors.</li> </ul>"},{"location":"content/pulseshaping/optimized/#example","title":"Example","text":"<p><pre><code>import torch\n\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig, PulseShapingConfig\nfrom qoolqit._solvers.types import BackendType, DeviceType\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.qubo_types import PulseType\n\n\nQ = torch.tensor([[-63.9423,   0.0000], [0.0000, -44.1916]])\n\ninstance = QUBOInstance(Q)\n\ndefault_config = SolverConfig(\n    use_quantum = True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED), n_calls = 25\n)\nsolver = QuboSolver(instance, default_config)\n\nsolution = solver.solve()\nprint(solution)\n</code></pre>   QUBOSolution(bitstrings=tensor([[1, 1]]), costs=tensor([-108.1339]), counts=None, probabilities=None, solution_status=)    This will return a <code>QUBOSolution</code> instance, which comprehends the solution bitstrings, the counts of each bitstring, their probabilities and costs."},{"location":"contributing/first%20contact/","title":"First contact","text":""},{"location":"contributing/first%20contact/#getting-the-code","title":"Getting the code","text":"<p>The code is available on GitHub.</p> <p>To clone it</p> <pre><code>$ git clone git@github.com:pasqal-io/qubo-solver.git\n</code></pre> <p>or</p> <pre><code>$ git clone https://github.com/pasqal-io/qubo-solver.git\n</code></pre>"},{"location":"contributing/first%20contact/#hatch-instructions","title":"Hatch instructions","text":"<p>We use <code>hatch</code> and Python 3.11 for development.</p>"},{"location":"contributing/first%20contact/#setting-up","title":"Setting up","text":"<p>With Python and pip installed, to setup the environment:</p> <pre><code>$ pip install hatch\n$ hatch -v shell\n</code></pre> <p>This will open a shell with all the dependencies installed.</p>"},{"location":"contributing/first%20contact/#running-tests","title":"Running tests","text":"<p>To run the unit and integration tests</p> <pre><code>$ hatch run test\n</code></pre> <p>To run linters</p> <pre><code>$ hatch run pre-commit run --all-files\n</code></pre>"},{"location":"contributing/how%20to%20contribute/","title":"How to contribute","text":"<p>We're grateful for your interest in contributing to this library!</p>"},{"location":"contributing/how%20to%20contribute/#asking-questions","title":"Asking questions","text":"<p>If you have any question about this library, don't hesitate to ask!</p> <p>For more information on how to get in touch, see our Community Portal. In particular, we have a Community Chat, it's generally the best place to ask questions.</p>"},{"location":"contributing/how%20to%20contribute/#providing-feedback-requesting-features-and-filing-bugs","title":"Providing feedback, requesting features and filing bugs","text":"<p>We're very interested in your feedback!</p> <p>The best way to request a change, whether it's an improvement, a new feature or a bugfix, is through GitHub issues. Before filing a new issue, don't forget to search if there's already an issue on the same topic.</p> <p>If you're willing to help getting that issue resolved, that's even better! See the next section.</p>"},{"location":"contributing/how%20to%20contribute/#opening-pull-requests","title":"Opening Pull Requests","text":"<p>We're grateful for your Pull Requests (i.e. submissions) to the code, documentation, tutorials, even this document!</p> <p>Before your first Pull Request, you'll need to:</p> <ol> <li>Fork the repository;</li> <li>Clone your forked repository locally, either through the GitHub console, or <pre><code>$ git clone git@github.com:YOUR_USERNAME/qubo-solver.git\n$ cd qubo-solver\n$ git remote add upstream https://github.com/pasqal-io/qubo-solver.git\n</code></pre></li> <li>Setup your development environment.</li> </ol> <p>Before you open a Pull Request, please make sure that you have:</p> <ul> <li>read the contributor agreement</li> <li>followed all the testing instructions.</li> </ul> <p>Our testing infrastructure will check whether your changes to the code or documentation break anything. If they don't, this will start the review cycle, during which we'll discuss with you to understand the purpose of your change, fix any issue and, hopefully, get your code merged!</p>"},{"location":"contributing/how%20to%20contribute/#one-word-about-patents","title":"One word about patents","text":"<p>The domain of Quantum Computing is heavily patented. If you contribute a new quantum algorithm (and not just an improvement to the library), please make sure that it's not covered by a patent!</p>"},{"location":"contributing/releasing/","title":"Releasing a new version","text":"<p>You only need to read this document if you're a maintainer of this library.</p> <p>Steps to release a new version:</p> <ol> <li>Bump up the version number in pyproject.toml (e.g. <code>0.7.9</code>).</li> <li>Bump up the links in the <code>README.md</code> that point to specific versions of the documentation.</li> <li>Open a Pull Request.</li> <li>Get it merged.</li> <li>Optionally, test a pre-release<ol> <li>Open the GitHub \"draft new release\" panel.</li> <li>Create a new tag (e.g. <code>v0.7.9rc1</code>).</li> <li>Mark the release as \"pre-release\".</li> <li>Confirm the release.</li> <li>Check in the Actions that the <code>publish</code> action has succeeded.</li> </ol> </li> <li>Actually release.<ol> <li>Open the GitHub \"draft new release\" panel.</li> <li>Create a new tag (e.g. <code>v0.7.9rc1</code>).</li> <li>Mark the release as \"latest release\".</li> <li>Confirm the release.</li> <li>Check in the Actions that the <code>publish</code> action has succeeded.</li> </ol> </li> </ol>"},{"location":"tutorial/01-dataset-generation-and-loading/","title":"Create datasets","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport torch\nfrom pathlib import Path\nfrom qubosolver import QUBODataset\nfrom qubosolver.saveload import save_qubo_dataset, load_qubo_dataset\n\noutput_directory = Path(str(os.path.abspath(\"01-dataset-generation-and-loading\")).replace(\"docs/tutorial\", \"qubosolver_logs/tutorial\"))\ndataset_sizes = range(5, 101, 5)\ninstances_per_size = 10\ndensities_list = [0.6]\ncoefficient_bounds = (-100.0, 100.0)\nseed = 42\n\n\ndef create_and_save_dataset(\n    output_dir: str,\n    dataset_name: str,\n    size: int,\n    num_instances: int,\n    densities: list[float],\n    coefficient_bounds: tuple[float, float],\n    device: str = \"cpu\",\n    dtype: torch.dtype = torch.float32,\n    seed: int | None = None,\n):\n    \"\"\"\n    Create a QUBODataset with bounds on fixed coefficient and save.\n\n    Args:\n        output_dir (str): Output directory.\n        dataset_name (str): File name to generate.\n        size (int): Dimension of QUBO (size x size).\n        num_instances (int): Number of instances for each density.\n        densities (list[float]): List of densities (ratio of non-null elements).\n        coefficient_bounds (tuple[float, float]): Interval (min, max) of non-null values.\n        device (str): Device (\u201ccpu\u201d ou \u201ccuda\u201d).\n        dtype (torch.dtype): Tensor dtype.\n        seed (int | None): Seed for reproductibility.\n    \"\"\"\n    # G\u00e9n\u00e8re le dataset\n    dataset = QUBODataset.from_random(\n        n_matrices=num_instances,\n        matrix_dim=size,\n        densities=densities,\n        coefficient_bounds=coefficient_bounds,\n        device=device,\n        dtype=dtype,\n        seed=seed,\n    )\n\n    os.makedirs(output_dir, exist_ok=True)\n    file_path = os.path.join(output_dir, dataset_name)\n    save_qubo_dataset(dataset, file_path)\n    print(f\"Dataset saved to {file_path}\")\n    \n## to generate dataset, uncomment the below\n\n# if __name__ == \"__main__\":\n#     for size in dataset_sizes:\n#         fname = f\"raw_qubo_dataset_size_{size}.pt\"\n#         create_and_save_dataset(\n#             output_dir=output_directory,\n#             dataset_name=fname,\n#             size=size,\n#             num_instances=instances_per_size,\n#             densities=densities_list,\n#             coefficient_bounds=coefficient_bounds,\n#             device=\"cpu\",\n#             dtype=torch.float32,\n#             seed=seed,\n#         )\n</pre> import os import torch from pathlib import Path from qubosolver import QUBODataset from qubosolver.saveload import save_qubo_dataset, load_qubo_dataset  output_directory = Path(str(os.path.abspath(\"01-dataset-generation-and-loading\")).replace(\"docs/tutorial\", \"qubosolver_logs/tutorial\")) dataset_sizes = range(5, 101, 5) instances_per_size = 10 densities_list = [0.6] coefficient_bounds = (-100.0, 100.0) seed = 42   def create_and_save_dataset(     output_dir: str,     dataset_name: str,     size: int,     num_instances: int,     densities: list[float],     coefficient_bounds: tuple[float, float],     device: str = \"cpu\",     dtype: torch.dtype = torch.float32,     seed: int | None = None, ):     \"\"\"     Create a QUBODataset with bounds on fixed coefficient and save.      Args:         output_dir (str): Output directory.         dataset_name (str): File name to generate.         size (int): Dimension of QUBO (size x size).         num_instances (int): Number of instances for each density.         densities (list[float]): List of densities (ratio of non-null elements).         coefficient_bounds (tuple[float, float]): Interval (min, max) of non-null values.         device (str): Device (\u201ccpu\u201d ou \u201ccuda\u201d).         dtype (torch.dtype): Tensor dtype.         seed (int | None): Seed for reproductibility.     \"\"\"     # G\u00e9n\u00e8re le dataset     dataset = QUBODataset.from_random(         n_matrices=num_instances,         matrix_dim=size,         densities=densities,         coefficient_bounds=coefficient_bounds,         device=device,         dtype=dtype,         seed=seed,     )      os.makedirs(output_dir, exist_ok=True)     file_path = os.path.join(output_dir, dataset_name)     save_qubo_dataset(dataset, file_path)     print(f\"Dataset saved to {file_path}\")      ## to generate dataset, uncomment the below  # if __name__ == \"__main__\": #     for size in dataset_sizes: #         fname = f\"raw_qubo_dataset_size_{size}.pt\" #         create_and_save_dataset( #             output_dir=output_directory, #             dataset_name=fname, #             size=size, #             num_instances=instances_per_size, #             densities=densities_list, #             coefficient_bounds=coefficient_bounds, #             device=\"cpu\", #             dtype=torch.float32, #             seed=seed, #         ) In\u00a0[\u00a0]: Copied! <pre>def load_datasets_by_size(directory: str):\n    \"\"\"\n    Loads datasets from a directory by extracting the size from filenames.\n\n    Args:\n        directory (str): Path to the directory containing dataset files.\n\n    Returns:\n        dict[int, torch.Tensor]: A dictionary where keys are sizes and values are loaded datasets.\n    \"\"\"\n    # Regular expression to match filenames like \"raw_qubo_dataset_size_{size}.pt\"\n    pattern = r\"raw_qubo_dataset_size_(\\d+)\\.pt\"\n    datasets_by_size = {}\n    os.makedirs(directory, exist_ok=True)\n    for filename in os.listdir(directory):\n        match = re.match(pattern, filename)\n        if match:\n            size = int(match.group(1))\n            file_path = os.path.join(directory, filename)\n            dataset = load_qubo_dataset(file_path)\n            datasets_by_size[size] = dataset\n            print(f\"Loaded dataset with size {size} from {file_path}\")\n    return datasets_by_size\n</pre> def load_datasets_by_size(directory: str):     \"\"\"     Loads datasets from a directory by extracting the size from filenames.      Args:         directory (str): Path to the directory containing dataset files.      Returns:         dict[int, torch.Tensor]: A dictionary where keys are sizes and values are loaded datasets.     \"\"\"     # Regular expression to match filenames like \"raw_qubo_dataset_size_{size}.pt\"     pattern = r\"raw_qubo_dataset_size_(\\d+)\\.pt\"     datasets_by_size = {}     os.makedirs(directory, exist_ok=True)     for filename in os.listdir(directory):         match = re.match(pattern, filename)         if match:             size = int(match.group(1))             file_path = os.path.join(directory, filename)             dataset = load_qubo_dataset(file_path)             datasets_by_size[size] = dataset             print(f\"Loaded dataset with size {size} from {file_path}\")     return datasets_by_size <p>Datasets is a dict for all qubo datasets for different sizes</p> <ul> <li>datasets[5] = will give us the qubodatasets of size 5 with different densities and different disparities.</li> <li>the qubo dataset also has the solution component - which is None for all the datasets in the raw_datasets folder.</li> </ul> In\u00a0[\u00a0]: Copied! <pre>datasets = load_datasets_by_size(output_directory)\n</pre> datasets = load_datasets_by_size(output_directory) In\u00a0[\u00a0]: Copied! <pre>datasets\n</pre> datasets In\u00a0[\u00a0]: Copied! <pre>size = 5\ndata_size_5 = datasets[size]\n\nfirst_qubo_cofficents, first_qubo_solution = data_size_5[9]\nprint(f\"Coefficients : {first_qubo_cofficents}\")\nprint(f\"Solution : {first_qubo_solution}\") # None because raw data\n</pre> size = 5 data_size_5 = datasets[size]  first_qubo_cofficents, first_qubo_solution = data_size_5[9] print(f\"Coefficients : {first_qubo_cofficents}\") print(f\"Solution : {first_qubo_solution}\") # None because raw data  In\u00a0[\u00a0]: Copied! <pre>size = 5\nfor coefficients, solution  in datasets[size]:\n    print(f\"Size of the qubo {size}\")\n    print(f\"Coefficients : {coefficients}\")\n    print(f\"Solution : {solution}\") # None because raw data\n\n    break\n</pre> size = 5 for coefficients, solution  in datasets[size]:     print(f\"Size of the qubo {size}\")     print(f\"Coefficients : {coefficients}\")     print(f\"Solution : {solution}\") # None because raw data      break  In\u00a0[\u00a0]: Copied! <pre>for size, dataset in datasets.items():\n    for coefficients, solution  in dataset:\n        print(f\"Size of the qubo {size}\")\n        print(f\"Coefficients : {coefficients}\")\n        print(f\"Solution : {solution}\") # None because raw data\n\n\n        break\n    break\n</pre> for size, dataset in datasets.items():     for coefficients, solution  in dataset:         print(f\"Size of the qubo {size}\")         print(f\"Coefficients : {coefficients}\")         print(f\"Solution : {solution}\") # None because raw data           break     break In\u00a0[\u00a0]: Copied! <pre>from qubosolver.utils import calculate_density\n\nfor size, dataset in datasets.items():\n    for coefficients, solution  in dataset:\n        print(f\"Size of the qubo {size}\")\n        print(f\"Coefficients : {coefficients}\")\n        print(f\"Solution : {solution}\") # None because raw data\n        print(f\"Density : {calculate_density(coefficients, size)}\") \n        break\n    break\n</pre> from qubosolver.utils import calculate_density  for size, dataset in datasets.items():     for coefficients, solution  in dataset:         print(f\"Size of the qubo {size}\")         print(f\"Coefficients : {coefficients}\")         print(f\"Solution : {solution}\") # None because raw data         print(f\"Density : {calculate_density(coefficients, size)}\")          break     break In\u00a0[\u00a0]: Copied! <pre>from qubosolver import QUBOInstance\n</pre> from qubosolver import QUBOInstance In\u00a0[\u00a0]: Copied! <pre>for size, dataset in datasets.items():\n    for coefficients, solution  in dataset:\n        print(f\"Size of the qubo {size}\")\n        print(f\"Coefficients : {coefficients}\")\n        print(f\"Solution : {solution}\") # None because raw data\n        \n        qubo_inst = QUBOInstance(coefficients)\n        print(f\"QUBO Instance : {qubo_inst}\")\n\n\n\n        break\n    break\n</pre> for size, dataset in datasets.items():     for coefficients, solution  in dataset:         print(f\"Size of the qubo {size}\")         print(f\"Coefficients : {coefficients}\")         print(f\"Solution : {solution}\") # None because raw data                  qubo_inst = QUBOInstance(coefficients)         print(f\"QUBO Instance : {qubo_inst}\")            break     break In\u00a0[\u00a0]: Copied! <pre>from qubosolver.data import QUBOSolution\n</pre> from qubosolver.data import QUBOSolution In\u00a0[\u00a0]: Copied! <pre>size = 5\ncoff = None\nsolutions = []\n\nfor i in range(10):\n    coefficients, _ = datasets[size][i]\n    # print(f\"Size of the qubo {size}\")\n    # print(f\"Coefficients : {coefficients}\")\n    if coff is None:\n        coff = coefficients.unsqueeze(2)\n    else:\n        coff = torch.cat((coff, coefficients.unsqueeze(2)), dim=2)\n    \n    qubo_inst = QUBOInstance(coefficients)\n    print(f\"QUBO Instance : {qubo_inst}\")\n\n    # Do your processing \n    # the solution should be saved in the QUBO Instance\n    # and can be extracted as\n    # qubo_solution = qubo_inst.solution\n    # But here we just define outside, as the solver is not defined yet. \n    qubo_sol = QUBOSolution(bitstrings=torch.Tensor([[1, 0, 1, 1, 0]]), \n                            costs=torch.Tensor([0.5]))\n    solutions.append(qubo_sol)\n    print(\"Updated Solution : \", qubo_sol)\n</pre> size = 5 coff = None solutions = []  for i in range(10):     coefficients, _ = datasets[size][i]     # print(f\"Size of the qubo {size}\")     # print(f\"Coefficients : {coefficients}\")     if coff is None:         coff = coefficients.unsqueeze(2)     else:         coff = torch.cat((coff, coefficients.unsqueeze(2)), dim=2)          qubo_inst = QUBOInstance(coefficients)     print(f\"QUBO Instance : {qubo_inst}\")      # Do your processing      # the solution should be saved in the QUBO Instance     # and can be extracted as     # qubo_solution = qubo_inst.solution     # But here we just define outside, as the solver is not defined yet.      qubo_sol = QUBOSolution(bitstrings=torch.Tensor([[1, 0, 1, 1, 0]]),                              costs=torch.Tensor([0.5]))     solutions.append(qubo_sol)     print(\"Updated Solution : \", qubo_sol)  In\u00a0[\u00a0]: Copied! <pre>new_dataset = QUBODataset(coefficients=coff, solutions=solutions)\n</pre> new_dataset = QUBODataset(coefficients=coff, solutions=solutions) In\u00a0[\u00a0]: Copied! <pre>new_dataset[0]\n</pre> new_dataset[0]"},{"location":"tutorial/01-dataset-generation-and-loading/#create-datasets","title":"Create datasets\u00b6","text":"<p>We create datasets for different sizes and save them in data/raw_datasets folder</p>"},{"location":"tutorial/01-dataset-generation-and-loading/#load-datasets","title":"Load datasets\u00b6","text":"<p>Here we load the datasets and show they can be used.</p>"},{"location":"tutorial/01-dataset-generation-and-loading/#dataset-of-a-specific-size","title":"Dataset of a specific size\u00b6","text":""},{"location":"tutorial/01-dataset-generation-and-loading/#iterate-thorough-all-sizes","title":"Iterate thorough all sizes\u00b6","text":""},{"location":"tutorial/01-dataset-generation-and-loading/#density","title":"Density\u00b6","text":""},{"location":"tutorial/01-dataset-generation-and-loading/#creating-a-quboinstance","title":"Creating a QUBOInstance\u00b6","text":""},{"location":"tutorial/01-dataset-generation-and-loading/#add-a-solution","title":"Add a solution\u00b6","text":"<p>We can add solutions using QUBOSOlution class. This solution element is also available in the QUBOInstance, but can also be defined outside.</p> <ul> <li>We can further create a dataset from these solutions</li> </ul>"},{"location":"tutorial/02-preprocessing/","title":"Pre-processing","text":"In\u00a0[\u00a0]: Copied! <pre>from qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig\nfrom qubosolver.solver import QuboSolver\n\nqubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]])\nconfig = SolverConfig.from_kwargs(do_preprocessing = True, use_quantum = False, classical_solver_type=\"dwave_sa\")\n\nsolver = QuboSolver(qubo, config)\nsolution = solver.solve()\nprint(solution)\n</pre> from qubosolver import QUBOInstance from qubosolver.config import SolverConfig from qubosolver.solver import QuboSolver  qubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]]) config = SolverConfig.from_kwargs(do_preprocessing = True, use_quantum = False, classical_solver_type=\"dwave_sa\")  solver = QuboSolver(qubo, config) solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[1., 1.]]), costs=tensor([-2.]), counts=None, probabilities=None, solution_status=&lt;SolutionStatusType.PREPROCESSED: 'preprocessed'&gt;)\n</pre> <p>We can access the number of variables fixed by preprocessing via the attribute <code>n_fixed_variables_preprocessing</code> from the solver:</p>"},{"location":"tutorial/02-preprocessing/#quickstart-solving-a-qubo-with-preprocessing-and-tabu-search","title":"Quickstart: Solving a QUBO with Preprocessing and Tabu Search\u00b6","text":"<p>This tutorial shows how to solve a simple QUBO problem using Tabu Search, with preprocessing enabled to reduce the problem size beforehand.</p>"},{"location":"tutorial/03-postprocessing/","title":"Post-processing","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport re\nfrom pathlib import Path\nfrom qubosolver.saveload import load_qubo_dataset\noutput_directory = Path(str(os.path.abspath(\"01-dataset-generation-and-loading\")).replace(\"docs/tutorial\", \"qubosolver_logs/tutorial\"))\n\ndef load_datasets_by_size(directory: str):\n    \"\"\"\n    Loads datasets from a directory by extracting the size from filenames.\n\n    Args:\n        directory (str): Path to the directory containing dataset files.\n\n    Returns:\n        dict[int, torch.Tensor]: A dictionary where keys are sizes and values are loaded datasets.\n    \"\"\"\n    # Regular expression to match filenames like \"raw_qubo_dataset_size_{size}.pt\"\n    pattern = r\"raw_qubo_dataset_size_(\\d+)\\.pt\"\n    datasets_by_size = {}\n    os.makedirs(directory, exist_ok=True)\n    for filename in os.listdir(directory):\n        match = re.match(pattern, filename)\n        if match:\n            size = int(match.group(1))\n            file_path = os.path.join(directory, filename)\n            dataset = load_qubo_dataset(file_path)\n            datasets_by_size[size] = dataset\n            print(f\"Loaded dataset with size {size} from {file_path}\")\n    return datasets_by_size\ndatasets = load_datasets_by_size(output_directory)\nsize = 20\ndata_size_5 = datasets[size]\n\nqubo_cofficents, first_qubo_solution = data_size_5[9]\nprint(f\"Coefficients : {qubo_cofficents}\")\n</pre> import os import re from pathlib import Path from qubosolver.saveload import load_qubo_dataset output_directory = Path(str(os.path.abspath(\"01-dataset-generation-and-loading\")).replace(\"docs/tutorial\", \"qubosolver_logs/tutorial\"))  def load_datasets_by_size(directory: str):     \"\"\"     Loads datasets from a directory by extracting the size from filenames.      Args:         directory (str): Path to the directory containing dataset files.      Returns:         dict[int, torch.Tensor]: A dictionary where keys are sizes and values are loaded datasets.     \"\"\"     # Regular expression to match filenames like \"raw_qubo_dataset_size_{size}.pt\"     pattern = r\"raw_qubo_dataset_size_(\\d+)\\.pt\"     datasets_by_size = {}     os.makedirs(directory, exist_ok=True)     for filename in os.listdir(directory):         match = re.match(pattern, filename)         if match:             size = int(match.group(1))             file_path = os.path.join(directory, filename)             dataset = load_qubo_dataset(file_path)             datasets_by_size[size] = dataset             print(f\"Loaded dataset with size {size} from {file_path}\")     return datasets_by_size datasets = load_datasets_by_size(output_directory) size = 20 data_size_5 = datasets[size]  qubo_cofficents, first_qubo_solution = data_size_5[9] print(f\"Coefficients : {qubo_cofficents}\") In\u00a0[\u00a0]: Copied! <pre>from qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig\nfrom qubosolver.solver import QuboSolver\n\n\ninstance = QUBOInstance(qubo_cofficents)\n\n# Create a SolverConfig object with classical solver options.\nconfig = SolverConfig.from_kwargs(\n    use_quantum=False,\n    classical_solver_type=\"dwave_tabu\", \n    do_postprocessing=True\n)\n\n# Instantiate the classical solver using the dispatcher.\nclassical_solver = QuboSolver(instance, config)\n\n# Solve the QUBO problem.\nsolution = classical_solver.solve()\nprint(\"Solution result:\", solution)\n</pre> from qubosolver import QUBOInstance from qubosolver.config import SolverConfig from qubosolver.solver import QuboSolver   instance = QUBOInstance(qubo_cofficents)  # Create a SolverConfig object with classical solver options. config = SolverConfig.from_kwargs(     use_quantum=False,     classical_solver_type=\"dwave_tabu\",      do_postprocessing=True )  # Instantiate the classical solver using the dispatcher. classical_solver = QuboSolver(instance, config)  # Solve the QUBO problem. solution = classical_solver.solve() print(\"Solution result:\", solution)"},{"location":"tutorial/03-postprocessing/#load-a-qubo-from-the-dataset","title":"Load a QUBO from the dataset\u00b6","text":""},{"location":"tutorial/03-postprocessing/#postprocessing-after-a-tabu-search-heuristic","title":"Postprocessing after a tabu search heuristic\u00b6","text":""},{"location":"tutorial/04-blade/","title":"BLaDE","text":"In\u00a0[\u00a0]: Copied! <pre>from qubosolver.algorithms.blade.blade import em_blade\nfrom qubosolver.algorithms.blade._helpers import interaction_matrix_from_positions, normalized_distance\nfrom pulser.devices import AnalogDevice\nimport numpy as np\nfrom pulser import Register\nimport dataclasses\nimport matplotlib.pyplot as plt\n\nnp.set_printoptions(precision=1, suppress=True)\nnp.random.seed(0)\n\ndevice = AnalogDevice\n</pre> from qubosolver.algorithms.blade.blade import em_blade from qubosolver.algorithms.blade._helpers import interaction_matrix_from_positions, normalized_distance from pulser.devices import AnalogDevice import numpy as np from pulser import Register import dataclasses import matplotlib.pyplot as plt  np.set_printoptions(precision=1, suppress=True) np.random.seed(0)  device = AnalogDevice In\u00a0[\u00a0]: Copied! <pre>qubo = np.array(\n      [[  0.,   3.,  13., 211.,  49.,   5.,  12.,   0.,   0.],\n       [  0.,   0.,  23.,   0.,   0.,   4.,   0.,  63.,   2.],\n       [  0.,   0.,   0.,   5.,   0.,   1.,   0.,   1.,   0.],\n       [  0.,   0.,   0.,   0.,  37.,   0.,   1.,   0.,   0.],\n       [  0.,   0.,   0.,   0.,   0.,   1.,  34.,   0.,   0.],\n       [  0.,   0.,   0.,   0.,   0.,   0.,  35.,   9.,  34.],\n       [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   1.],\n       [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  70.],\n       [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.]])\n</pre> qubo = np.array(       [[  0.,   3.,  13., 211.,  49.,   5.,  12.,   0.,   0.],        [  0.,   0.,  23.,   0.,   0.,   4.,   0.,  63.,   2.],        [  0.,   0.,   0.,   5.,   0.,   1.,   0.,   1.,   0.],        [  0.,   0.,   0.,   0.,  37.,   0.,   1.,   0.,   0.],        [  0.,   0.,   0.,   0.,   0.,   1.,  34.,   0.,   0.],        [  0.,   0.,   0.,   0.,   0.,   0.,  35.,   9.,  34.],        [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   1.],        [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  70.],        [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.]]) <p>We call <code>em_blade</code> to em<code>BLaDE</code> the QUBO on the given device:</p> In\u00a0[\u00a0]: Copied! <pre>positions = em_blade(qubo, device=device)\n</pre> positions = em_blade(qubo, device=device) <p>We compute the interaction matrix for the chosen positions, and observe that the coefficients are close to those of the QUBO:</p> In\u00a0[\u00a0]: Copied! <pre>interactions = interaction_matrix_from_positions(positions, device=device)\ninteractions\n</pre> interactions = interaction_matrix_from_positions(positions, device=device) interactions Out[\u00a0]: <pre>array([[  0. ,   1.1,  14.2, 211.3,  49.2,   5.5,  12.2,   0.3,   0.2],\n       [  0. ,   0. ,  23.2,   0.2,   0.1,   4.3,   0.3,  62.8,   1.8],\n       [  0. ,   0. ,   0. ,   3.1,   0.4,   1.3,   0.4,   0.7,   0.2],\n       [  0. ,   0. ,   0. ,   0. ,  35.9,   0.4,   1.3,   0.1,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   1.1,  33.3,   0.1,   0.1],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,  34.2,   8.4,  34.4],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0.3,   0.8],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,  69.8],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ]])</pre> <p>We also compute the distance between the QUBO and the actual interaction matrix, to quickly evaluate how low it is:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_distance(target=qubo, actual=interactions)\n</pre> normalized_distance(target=qubo, actual=interactions) Out[\u00a0]: <pre>np.float64(0.014640405371090463)</pre> <p>On next sections, we describe how additional parameters can be set to tune the algorithm's behavior.</p> In\u00a0[\u00a0]: Copied! <pre>positions = em_blade(qubo, device=device, dimensions=[3,2,2], steps_per_round=50)\n</pre> positions = em_blade(qubo, device=device, dimensions=[3,2,2], steps_per_round=50) <p>We observe however that the coefficients are less accurate:</p> In\u00a0[\u00a0]: Copied! <pre>interactions = interaction_matrix_from_positions(positions, device=device)\ninteractions\n</pre> interactions = interaction_matrix_from_positions(positions, device=device) interactions Out[\u00a0]: <pre>array([[  0. ,   0.2,   0. , 205.8,  45.9,   5.5,   3.4,   0.4,   0.2],\n       [  0. ,   0. ,   0. ,   0.1,   0. ,   0. ,   0. ,  68.1,   1.1],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,  43.3,   0.5,   0.9,   0.1,   0.1],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   2.2,  41.9,   0. ,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,  22.9,   0.2,   0.6],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,  73.2],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ]])</pre> <p>It is also reflected by the distance:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_distance(target=qubo, actual=interactions)\n</pre> normalized_distance(target=qubo, actual=interactions) Out[\u00a0]: <pre>np.float64(0.19477242052393182)</pre> <p>Depending on the target matrices and their sizes, in general, it is for the user to try different values to find the best compromise between speed and quality of result.</p> <p>It is also possible to input initial positions, to replace the usual random starting positions that the function computes. For example, here, we can use the positions obtained from the previous run to re-optimize them. Since the provided positions are in 2 dimensions, we have to start on 2 dimensions. Then, we can increase the number of dimensions, before returning to 2 dimensions:</p> In\u00a0[\u00a0]: Copied! <pre>positions = em_blade(qubo, starting_positions=positions, device=device, dimensions=[2,4,4,2], steps_per_round=100)\n</pre> positions = em_blade(qubo, starting_positions=positions, device=device, dimensions=[2,4,4,2], steps_per_round=100) <p>The new interactions are:</p> In\u00a0[\u00a0]: Copied! <pre>interactions = interaction_matrix_from_positions(positions, device=device)\ninteractions\n</pre> interactions = interaction_matrix_from_positions(positions, device=device) interactions Out[\u00a0]: <pre>array([[  0. ,   0.6,   0.1, 213.9,  43.4,   8.2,   9.1,   2.8,   0.7],\n       [  0. ,   0. ,  28.4,   0.2,   0.1,   0.3,   0.1,  64.6,   1.3],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0.1,   0. ,   3.3,   0.7],\n       [  0. ,   0. ,   0. ,   0. ,  37.9,   0.5,   1.2,   0.4,   0.1],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   1.4,  33.4,   0.2,   0.1],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,  32.3,   6.8,  35.6],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0.3,   0.5],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,  73.4],\n       [  0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ,   0. ]])</pre> <p>And the new distance is:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_distance(target=qubo, actual=interactions)\n</pre> normalized_distance(target=qubo, actual=interactions) Out[\u00a0]: <pre>np.float64(0.07469311934721067)</pre> <p>The distance has decreased, although more iterations and/or more dimensions would be required to improve the result further.</p> In\u00a0[\u00a0]: Copied! <pre>qubo = np.array([\n    [0, 1, 0, 0, 1, 1],\n    [0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0, 1],\n    [0, 0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0],\n])\n</pre> qubo = np.array([     [0, 1, 0, 0, 1, 1],     [0, 0, 1, 0, 0, 0],     [0, 0, 0, 1, 0, 1],     [0, 0, 0, 0, 1, 0],     [0, 0, 0, 0, 0, 1],     [0, 0, 0, 0, 0, 0], ]) <p>We embed it using the default parameters:</p> In\u00a0[\u00a0]: Copied! <pre>positions = em_blade(qubo, device=device)\ninteractions = interaction_matrix_from_positions(positions, device=device)\ninteractions\n</pre> positions = em_blade(qubo, device=device) interactions = interaction_matrix_from_positions(positions, device=device) interactions Out[\u00a0]: <pre>array([[0. , 0.4, 0. , 0. , 0.2, 1.5],\n       [0. , 0. , 0.3, 0. , 0. , 0.3],\n       [0. , 0. , 0. , 0.3, 0. , 1.5],\n       [0. , 0. , 0. , 0. , 0.4, 0.3],\n       [0. , 0. , 0. , 0. , 0. , 1.5],\n       [0. , 0. , 0. , 0. , 0. , 0. ]])</pre> <p>We observe that each coefficient of the QUBO is taken into account, but very badly. In fact, they are competitve and cannot be satisfied at the same time. The resulting distance is:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_distance(target=qubo, actual=interactions)\n</pre> normalized_distance(target=qubo, actual=interactions) Out[\u00a0]: <pre>np.float64(0.6569661333473285)</pre> <p>We create a function <code>compute_max_distance_to_walk</code> that will decide at each step a maximum move length for points to achieve objectives. In the beginning (starting with <code>x=0</code>), it is large enough for points to explore without much constraint, but approaching the last steps (targetting <code>x=1</code>), it starts decaying toward 0, forcing points to move more slowly, and satisfy easier objectives in priority:</p> In\u00a0[\u00a0]: Copied! <pre>def compute_max_distance_to_walk(x, _):\n    unit_dist = device.rydberg_blockade_radius(1)\n    return unit_dist * (1 - np.sin(x * np.pi / 2))\n\nx = np.linspace(0, 1, 50)\ny = [compute_max_distance_to_walk(x_val, None) for x_val in x]\nplt.plot(x, y)\nplt.xlabel('Steps progress fraction')\nplt.ylabel('Maximum distance to walk')\nplt.show()\n</pre> def compute_max_distance_to_walk(x, _):     unit_dist = device.rydberg_blockade_radius(1)     return unit_dist * (1 - np.sin(x * np.pi / 2))  x = np.linspace(0, 1, 50) y = [compute_max_distance_to_walk(x_val, None) for x_val in x] plt.plot(x, y) plt.xlabel('Steps progress fraction') plt.ylabel('Maximum distance to walk') plt.show() <p>The function is assigned to the parameter <code>compute_max_distance_to_walk</code>, and we run BLaDE:</p> In\u00a0[\u00a0]: Copied! <pre>positions = em_blade(qubo, device=device, compute_max_distance_to_walk=compute_max_distance_to_walk)\ninteractions = interaction_matrix_from_positions(positions, device=device)\ninteractions\n</pre> positions = em_blade(qubo, device=device, compute_max_distance_to_walk=compute_max_distance_to_walk) interactions = interaction_matrix_from_positions(positions, device=device) interactions Out[\u00a0]: <pre>array([[0. , 1. , 0.1, 0. , 0. , 1. ],\n       [0. , 0. , 1. , 0. , 0. , 0.1],\n       [0. , 0. , 0. , 1. , 0.1, 1. ],\n       [0. , 0. , 0. , 0. , 1. , 0.1],\n       [0. , 0. , 0. , 0. , 0. , 1. ],\n       [0. , 0. , 0. , 0. , 0. , 0. ]])</pre> <p>Now, the interactions are much closer to the target matrix. In fact, they are all close to perfection, except one, that has been abandoned, between points 0 and 4.</p> <p>The resulting distance reflects that improvement:</p> In\u00a0[\u00a0]: Copied! <pre>normalized_distance(target=qubo, actual=interactions)\n</pre> normalized_distance(target=qubo, actual=interactions) Out[\u00a0]: <pre>np.float64(0.3591706664391691)</pre> In\u00a0[\u00a0]: Copied! <pre>device.max_radial_distance / device.min_atom_distance\n</pre> device.max_radial_distance / device.min_atom_distance Out[\u00a0]: <pre>7.6</pre> <p>BLaDE allows to enforce such a constraint, and optimizes the scaling on the minimum pairwise distance and the radius. The flag <code>enforce_min_max_dist_ratio</code> must be set to <code>True</code> to enable that feature.</p> <p>We define voluntarily a QUBO that requires a chain of atoms connected to each other, which can necessitate space. Each point is connected to the next two ones:</p> In\u00a0[\u00a0]: Copied! <pre>size = 25\nqubo = np.diag(np.ones(size-1), k=1) + np.diag(np.ones(size-2), k=2)\nqubo\n</pre> size = 25 qubo = np.diag(np.ones(size-1), k=1) + np.diag(np.ones(size-2), k=2) qubo Out[\u00a0]: <pre>array([[0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n        1., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        1., 1., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 1., 1., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 1., 1., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 1., 1., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 1., 1., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 1., 1., 0., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 1., 1., 0.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 1., 1.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 1.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0.]])</pre> <p>We em<code>BLaDE</code> the target matrix using the default method, and draw the result:</p> In\u00a0[\u00a0]: Copied! <pre>positions = em_blade(qubo, device=device)\nRegister.from_coordinates(positions).draw()\n</pre> positions = em_blade(qubo, device=device) Register.from_coordinates(positions).draw() <pre>/Users/deterrasson/Library/Application Support/hatch/env/virtual/qubo-solver/gLB2xHGn/qubo-solver/lib/python3.10/site-packages/pulser/register/register.py:58: DeprecationWarning: Usage of `int`s or any non-`str`types as `QubitId`s will be deprecated. Define your `QubitId`s as `str`s, prefer setting `prefix='q'` when using classmethods, as that will become the new default once `int` qubit IDs become invalid.\n  super().__init__(qubits, **kwargs)\n</pre> <p>We can see that the radius of the circle that contains the atoms is too high compared to the spacing between them. We set the flag <code>enforce_min_max_dist_ratio</code> to enforce the ratio constraint:</p> In\u00a0[\u00a0]: Copied! <pre>positions = em_blade(qubo, device=device, enforce_min_max_dist_ratio=True)\ninteractions = interaction_matrix_from_positions(positions, device=device)\nRegister.from_coordinates(positions).draw()\n</pre> positions = em_blade(qubo, device=device, enforce_min_max_dist_ratio=True) interactions = interaction_matrix_from_positions(positions, device=device) Register.from_coordinates(positions).draw() <pre>/Users/deterrasson/Library/Application Support/hatch/env/virtual/qubo-solver/gLB2xHGn/qubo-solver/lib/python3.10/site-packages/pulser/register/register.py:58: DeprecationWarning: Usage of `int`s or any non-`str`types as `QubitId`s will be deprecated. Define your `QubitId`s as `str`s, prefer setting `prefix='q'` when using classmethods, as that will become the new default once `int` qubit IDs become invalid.\n  super().__init__(qubits, **kwargs)\n</pre> <p>Now, the register of atoms is naturally twisted, which allows to meet the ratio constraint.</p>"},{"location":"tutorial/04-blade/#blade","title":"BLaDE\u00b6","text":"<p>BLaDE (Balanced Latently Dimensional Embedder) is a method designed at PASQAL that allows to find best positions for atoms for a given problem. We say that we embed the problem, and the resulting placement of atoms is called a register or embedding. When atoms have been prepared in the vacuum chamber of the QPU, they can interact with each other when they are close neighbors. When they are set farther apart, the interaction on each pair of atoms decays rapidly. The formula that defines the amplitude of interaction is $\\frac{C_6}{R^6}$, where $C_6$ is a constant that depends on the QPU, and $R$ is the distance between two atoms. Given positions for atoms, we name interaction matrix the matrix that contains the amplitude of interaction on each pair of atoms.</p> <p>When solving a problem on the QPU, in general, we want to target a specific interaction matrix. In particular, when solving a QUBO, we want the interaction matrix to mimic the QUBO matrix, such that each interaction corresponds to a quadratic term of the QUBO.</p> <p>BLaDE allows to look for the best way to position the atoms, such that the interaction matrix is as close to a target matrix as possible. If the target matrix is a QUBO, it can be used to prepare a register to solve a QUBO. It is an iterative algorithm, that starts from initial positions (e.g. random positions). Then, at each step, it moves points using \"forces\" to make each interaction get closer to the corresponding quadratic term. In that matter, it takes inspiration from the Fruchterman-Reingold algorithm.</p> <p>Here, we define a target matrix as the quadratic terms of a QUBO:</p>"},{"location":"tutorial/04-blade/#tuning-the-steps","title":"Tuning the steps\u00b6","text":"<p>A feature of BLaDE is that it can go beyond 2 dimensions when evolving the positions. Higher dimensions allow to escape trapped situations, and lower dimensions allow to return to the often desired 2-dimensional space, since we need a register in 2 dimensions. To do so, we can set the parameter <code>dimensions</code> as a list of integers, from the starting number of dimensions up to the final one.</p> <p>On each period of the algorithm, when evolving from a number of dimensions to another one, a specific number of steps is performed. This can also be tuned by setting the parameter <code>steps_per_round</code>.</p> <p>Here is an example where we use fewer dimensions and a smaller number of steps per round than the default values of the function. As a result, it returns very quickly:</p>"},{"location":"tutorial/04-blade/#tuning-the-objectives","title":"Tuning the objectives\u00b6","text":"<p>By default, BLaDE applies forces to make each interaction as close as possible to the corresponding coefficient of the target matrix. However, there is sometimes no solution to meet all these objectives simulataneously. In such cases, it can be judicious to give up on some objectives, to better meet other ones. It allows the solution to have a smaller distance from the target overall.</p> <p>For example, let us take the following target matrix:</p>"},{"location":"tutorial/04-blade/#meet-the-devices-constraints","title":"Meet the device's constraints\u00b6","text":"<p>Real device have constraints on the coordinates: atoms can not get closer than a given distance, and they must all fit in a disk under a given radius. Since a QUBO matrix can be multiplied by any non zero factor and remains equivalent, distances can also be scaled. Thus, the actual constraint to satisfy is the ratio between the radius and the minimum pairwise distance. The device for this tutorial has the following ratio:</p>"},{"location":"tutorial/04-qubo-embedding/","title":"Qubo embedding","text":"In\u00a0[\u00a0]: Copied! <pre>import torch\n\nfrom qubosolver.config import DeviceType, EmbeddingConfig, SolverConfig\nfrom qubosolver.solver import QUBOInstance, QuboSolver\n</pre> import torch  from qubosolver.config import DeviceType, EmbeddingConfig, SolverConfig from qubosolver.solver import QUBOInstance, QuboSolver  In\u00a0[\u00a0]: Copied! <pre># import QUBO matrix manually\ncoefficients = torch.load(\"qubo_size_15.pt\", weights_only=True)\ninstance = QUBOInstance(coefficients)\n</pre> # import QUBO matrix manually coefficients = torch.load(\"qubo_size_15.pt\", weights_only=True) instance = QUBOInstance(coefficients) <ol> <li>Define a <code>SolverConfig</code> to be passed to any solver</li> </ol> In\u00a0[\u00a0]: Copied! <pre>config = SolverConfig(use_quantum=True)\n</pre> config = SolverConfig(use_quantum=True) <p>For now, the <code>SolverConfig</code> contains parameters according to all available procedures (<code>pre-post processing</code>, <code>embedding</code>, <code>pulse shaping</code>). It has a default behavior that is compliant to the minimum requirements to run the workflow, as long as the given QUBO matrix fits with these default paremeters.</p> <p>If one want to access to the default attributes, it is easily readable through the following:</p> In\u00a0[\u00a0]: Copied! <pre>config.print_specs()\n</pre> config.print_specs() <pre>config_name: ''\nuse_quantum: True\nbackend_config: {'backend': &lt;BackendType.QUTIP: 'qutip'&gt;, 'username': None, 'password': None, 'project_id': None, 'device': None, 'dt': 10, 'wait': False}\nn_calls: 20\nembedding: {'embedding_method': &lt;EmbedderType.GREEDY: 'greedy'&gt;, 'layout_greedy_embedder': &lt;LayoutType.TRIANGULAR: &lt;class 'pulser.register.special_layouts.TriangularLatticeLayout'&gt;&gt;, 'steps_per_round_space_embedder': 150, 'starting_positions': None, 'dimensions': [2], 'traps': 1, 'spacing': 4.0, 'density': None, 'draw_steps': False, 'animation_save_path': None}\npulse_shaping: {'pulse_shaping_method': &lt;PulseType.ADIABATIC: 'adiabatic'&gt;, 'initial_omega_parameters': [5.0, 10.0, 5.0], 'initial_detuning_parameters': [-10.0, 0.0, 10.0], 're_execute_opt_pulse': False, 'custom_qubo_cost': None, 'custom_objective': None, 'callback_objective': None}\nclassical: {'classical_solver_type': 'cplex', 'cplex_maxtime': 600.0, 'cplex_log_path': 'solver.log'}\nnum_shots: 500\ndo_postprocessing: False\ndo_preprocessing: False\nactivate_trivial_solutions: True\n</pre> <ol> <li>Define a <code>QuboSolver</code>, by passing the instance and the defined configuration</li> </ol> In\u00a0[\u00a0]: Copied! <pre>solver = QuboSolver(instance, config)\n</pre> solver = QuboSolver(instance, config) <ol> <li>Call the embedding method according to the provided set of parameters defined by the <code>SolverConfig</code>.</li> </ol> In\u00a0[\u00a0]: Copied! <pre>geometry = solver.embedding()\n</pre> geometry = solver.embedding() <p>From the chosen embedding method, we get a set of two-dimensional coordinates that should be embeddable on the register:</p> In\u00a0[\u00a0]: Copied! <pre>geometry.register.draw()\n</pre> geometry.register.draw() In\u00a0[\u00a0]: Copied! <pre>blade_settings = EmbeddingConfig(embedding_method=\"blade\", blade_dimensions=[5 ,4, 3, 2], blade_steps_per_round=300)\nblade_config = SolverConfig.from_kwargs(\n    use_quantum=True,\n    device=DeviceType.ANALOG_DEVICE,\n    embedding=blade_settings,\n)\n\nsolver = QuboSolver(instance, blade_config)\ngeometry = solver.embedding()\ngeometry.register.draw()\n</pre> blade_settings = EmbeddingConfig(embedding_method=\"blade\", blade_dimensions=[5 ,4, 3, 2], blade_steps_per_round=300) blade_config = SolverConfig.from_kwargs(     use_quantum=True,     device=DeviceType.ANALOG_DEVICE,     embedding=blade_settings, )  solver = QuboSolver(instance, blade_config) geometry = solver.embedding() geometry.register.draw() In\u00a0[\u00a0]: Copied! <pre>greedy_settings = EmbeddingConfig(embedding_method=\"greedy\", layout_greedy_embedder=\"triangular\", traps=instance.size)\n\ngreedy_config = SolverConfig.from_kwargs(\n    use_quantum=True,\n    device=DeviceType.ANALOG_DEVICE,\n    embedding=greedy_settings,\n)\n\nsolver = QuboSolver(instance, greedy_config)\ngeometry = solver.embedding()\ngeometry.register.draw()\n</pre> greedy_settings = EmbeddingConfig(embedding_method=\"greedy\", layout_greedy_embedder=\"triangular\", traps=instance.size)  greedy_config = SolverConfig.from_kwargs(     use_quantum=True,     device=DeviceType.ANALOG_DEVICE,     embedding=greedy_settings, )  solver = QuboSolver(instance, greedy_config) geometry = solver.embedding() geometry.register.draw() In\u00a0[\u00a0]: Copied! <pre>import typing\nfrom qubosolver.pipeline.embedder import BaseEmbedder\nfrom qubosolver.pipeline.targets import Register as TargetRegister\nfrom qubosolver.config import SolverConfig\nfrom pulser.register import Register as PulserRegister\n\nclass FixedEmbedder(BaseEmbedder):\n\n    @typing.no_type_check\n    def embed(self) -&gt; TargetRegister:\n        qubits = {f\"q{i}\": (i,0) for i in range(self.instance.coefficients.shape[0])}\n        register = PulserRegister(qubits)\n        return TargetRegister(self.config.backend_config.device, register)\n\n\ncustom_config = SolverConfig.from_kwargs(\n    use_quantum=True,\n    embedding_method=FixedEmbedder,\n)\nsolver = QuboSolver(instance, custom_config)\ngeometry = solver.embedding()\ngeometry.register.draw()\n</pre> import typing from qubosolver.pipeline.embedder import BaseEmbedder from qubosolver.pipeline.targets import Register as TargetRegister from qubosolver.config import SolverConfig from pulser.register import Register as PulserRegister  class FixedEmbedder(BaseEmbedder):      @typing.no_type_check     def embed(self) -&gt; TargetRegister:         qubits = {f\"q{i}\": (i,0) for i in range(self.instance.coefficients.shape[0])}         register = PulserRegister(qubits)         return TargetRegister(self.config.backend_config.device, register)   custom_config = SolverConfig.from_kwargs(     use_quantum=True,     embedding_method=FixedEmbedder, ) solver = QuboSolver(instance, custom_config) geometry = solver.embedding() geometry.register.draw() In\u00a0[\u00a0]: Copied! <pre>from matplotlib import rc\nrc(\"animation\", html=\"jshtml\")  # ensure inline animations\n\nfrom importlib import reload\n\n\nfrom qubosolver.solver import QUBOInstance, QuboSolver\nfrom qubosolver.config import SolverConfig, EmbeddingConfig, BackendConfig\nfrom qoolqit._solvers.types import DeviceType\n\n \n</pre> from matplotlib import rc rc(\"animation\", html=\"jshtml\")  # ensure inline animations  from importlib import reload   from qubosolver.solver import QUBOInstance, QuboSolver from qubosolver.config import SolverConfig, EmbeddingConfig, BackendConfig from qoolqit._solvers.types import DeviceType    In\u00a0[\u00a0]: Copied! <pre>import torch\n\nQ = torch.tensor([\n    [-4.0, 1.0, 2.0, 1.5, 2.3, 0.9, 1.8, 2.7, 1.2],\n    [ 1.0,-3.2, 1.7, 2.1, 0.8, 1.9, 2.2, 1.1, 1.6],\n    [ 2.0, 1.7,-5.1, 0.7, 2.5, 1.3, 2.6, 1.4, 2.0],\n    [ 1.5, 2.1, 0.7,-2.7, 1.2, 2.4, 0.6, 1.8, 2.1],\n    [ 2.3, 0.8, 2.5, 1.2,-6.3, 1.0, 1.7, 2.8, 1.5],\n    [ 0.9, 1.9, 1.3, 2.4, 1.0,-4.5, 2.3, 1.6, 0.9],\n    [ 1.8, 2.2, 2.6, 0.6, 1.7, 2.3,-3.8, 1.2, 2.2],\n    [ 2.7, 1.1, 1.4, 1.8, 2.8, 1.6, 1.2,-5.9, 1.4],\n    [ 1.2, 1.6, 2.0, 2.1, 1.5, 0.9, 2.2, 1.4,-2.4],\n], dtype=torch.float32)\n\ninstance = QUBOInstance(Q)\n\ngreedy_settings = EmbeddingConfig(\n    embedding_method=\"greedy\",\n    layout_greedy_embedder=\"triangular\",  # or \"square\"\n    traps=instance.size + 6,\n    spacing=5.0,\n    draw_steps=True,                         # \u2190 single toggle\n    animation_save_path=\"greedy_demo.mp4\",   # \u2190 optional file export\n)\n\nbackend = BackendConfig(device=DeviceType.ANALOG_DEVICE)\n\ncfg = SolverConfig.from_kwargs(\n    use_quantum=True,\n    embedding=greedy_settings,\n    device=backend.device,\n)\n\nsolver = QuboSolver(instance, cfg)\ngeometry = solver.embedding()     # \u2192 inline animation + optional mp4\n</pre> import torch  Q = torch.tensor([     [-4.0, 1.0, 2.0, 1.5, 2.3, 0.9, 1.8, 2.7, 1.2],     [ 1.0,-3.2, 1.7, 2.1, 0.8, 1.9, 2.2, 1.1, 1.6],     [ 2.0, 1.7,-5.1, 0.7, 2.5, 1.3, 2.6, 1.4, 2.0],     [ 1.5, 2.1, 0.7,-2.7, 1.2, 2.4, 0.6, 1.8, 2.1],     [ 2.3, 0.8, 2.5, 1.2,-6.3, 1.0, 1.7, 2.8, 1.5],     [ 0.9, 1.9, 1.3, 2.4, 1.0,-4.5, 2.3, 1.6, 0.9],     [ 1.8, 2.2, 2.6, 0.6, 1.7, 2.3,-3.8, 1.2, 2.2],     [ 2.7, 1.1, 1.4, 1.8, 2.8, 1.6, 1.2,-5.9, 1.4],     [ 1.2, 1.6, 2.0, 2.1, 1.5, 0.9, 2.2, 1.4,-2.4], ], dtype=torch.float32)  instance = QUBOInstance(Q)  greedy_settings = EmbeddingConfig(     embedding_method=\"greedy\",     layout_greedy_embedder=\"triangular\",  # or \"square\"     traps=instance.size + 6,     spacing=5.0,     draw_steps=True,                         # \u2190 single toggle     animation_save_path=\"greedy_demo.mp4\",   # \u2190 optional file export )  backend = BackendConfig(device=DeviceType.ANALOG_DEVICE)  cfg = SolverConfig.from_kwargs(     use_quantum=True,     embedding=greedy_settings,     device=backend.device, )  solver = QuboSolver(instance, cfg) geometry = solver.embedding()     # \u2192 inline animation + optional mp4  <pre>[anim] Save failed: ffmpeg is not available in PATH. Install ffmpeg or export GIF instead.\nAnimation.save using &lt;class 'matplotlib.animation.HTMLWriter'&gt;\n</pre> Once Loop Reflect"},{"location":"tutorial/04-qubo-embedding/#embedding-worklow","title":"Embedding worklow\u00b6","text":"<p>This tutorial aims to show small code snippet on how to use the different embedding methods (<code>blade</code>, <code>custom</code>, <code>greedy</code>) as well as how to parametrize the algorithms through the <code>SolverConfig</code> according to a given QUBO matrix.</p>"},{"location":"tutorial/04-qubo-embedding/#blade-parametrization","title":"BLaDE parametrization\u00b6","text":"<p>Following previous workflow, we can reiterate using a more fined parametrization of the <code>SolverConfig</code> for the <code>blade</code> embedding method.</p> <p>Here is a code snippet of an arbitrary parametrization of BLaDE using multiple layers of $n$-dimension and a number of steps per round (i.e. number of iteration per layer):</p>"},{"location":"tutorial/04-qubo-embedding/#greedy-embedder-parametrization","title":"Greedy embedder parametrization\u00b6","text":"<p>We do the same using the <code>greedy</code> embedding method, using a triangular lattice layout on a <code>DigitalAnalogDevice</code> with a number of traps at least equal to the number of variables in the QUBO:</p>"},{"location":"tutorial/04-qubo-embedding/#custom-embedder","title":"Custom embedder\u00b6","text":"<p>If one desires to develop his own embedding method, a subclass of <code>qubosolver.pipeline.embedder.BaseEmbedder</code> should be implemented with a mandatory <code>embed</code> method.</p> <p>The <code>embed</code> method <code>def embed(self) -&gt; qubosolver.pipeline.targets.Register</code> specify how the problem is mapped into a register of qubits when running using a quantum device. Let us show a simple example where each variable $i$ is mapped into a qubit lying on a horizontal line (with coordinates $[i, 0]$).</p>"},{"location":"tutorial/04-qubo-embedding/#greedy-algorithm-vizualisation","title":"Greedy algorithm - Vizualisation\u00b6","text":""},{"location":"tutorial/05-pulse-shaping-methods/","title":"Demo - Pulse Shaping Methods","text":"In\u00a0[\u00a0]: Copied! <pre>import torch\n\nfrom qubosolver.qubo_instance import QUBOInstance\nfrom qubosolver.config import SolverConfig, PulseShapingConfig\nfrom qubosolver.qubo_types import PulseType\nfrom qubosolver.solver import QuboSolver\n</pre> import torch  from qubosolver.qubo_instance import QUBOInstance from qubosolver.config import SolverConfig, PulseShapingConfig from qubosolver.qubo_types import PulseType from qubosolver.solver import QuboSolver In\u00a0[\u00a0]: Copied! <pre>coefficients = torch.tensor([[-1.0, 0.5, 0.2], [0.5, -2.0, 0.3], [0.2, 0.3, -3.0]])\ninstance = QUBOInstance(coefficients)\n</pre> coefficients = torch.tensor([[-1.0, 0.5, 0.2], [0.5, -2.0, 0.3], [0.2, 0.3, -3.0]]) instance = QUBOInstance(coefficients) In\u00a0[\u00a0]: Copied! <pre>default_config = SolverConfig.from_kwargs(\n    use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.ADIABATIC),\n)\nsolver = QuboSolver(instance, default_config)\n\nsolution = solver.solve()\nprint(solution)\n</pre> default_config = SolverConfig.from_kwargs(     use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.ADIABATIC), ) solver = QuboSolver(instance, default_config)  solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[0., 0., 1.],\n        [0., 1., 0.],\n        [1., 0., 0.],\n        [0., 0., 0.]]), costs=tensor([-3., -2., -1.,  0.]), counts=tensor([ 83, 111, 120, 186], dtype=torch.int32), probabilities=tensor([0.1660, 0.2220, 0.2400, 0.3720]), solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre> In\u00a0[\u00a0]: Copied! <pre>default_config = SolverConfig.from_kwargs(\n    use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED),\n)\nsolver = QuboSolver(instance, default_config)\n\nsolution = solver.solve()\nprint(solution)\n</pre> default_config = SolverConfig.from_kwargs(     use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED), ) solver = QuboSolver(instance, default_config)  solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[0., 0., 1.],\n        [0., 1., 0.],\n        [1., 0., 0.],\n        [0., 0., 0.]]), costs=tensor([-3., -2., -1.,  0.]), counts=tensor([14, 18, 12, 56], dtype=torch.int32), probabilities=tensor([0.1400, 0.1800, 0.1200, 0.5600]), solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre> In\u00a0[\u00a0]: Copied! <pre>default_config = SolverConfig.from_kwargs(\n    use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED), n_calls=13\n)\nsolver = QuboSolver(instance, default_config)\n\nsolution = solver.solve()\nprint(solution)\n</pre> default_config = SolverConfig.from_kwargs(     use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED), n_calls=13 ) solver = QuboSolver(instance, default_config)  solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[0., 0., 1.],\n        [0., 1., 0.],\n        [1., 0., 0.],\n        [0., 0., 0.]]), costs=tensor([-3., -2., -1.,  0.]), counts=tensor([14, 16, 17, 53], dtype=torch.int32), probabilities=tensor([0.1400, 0.1600, 0.1700, 0.5300]), solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre> In\u00a0[\u00a0]: Copied! <pre>default_config = SolverConfig.from_kwargs(\n    use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED, initial_omega_parameters=[2.0, 15.0, 5.0,], initial_detuning_parameters=[-45.0, 0.0, 25.0]),\n)\nsolver = QuboSolver(instance, default_config)\n\nsolution = solver.solve()\nprint(solution)\n</pre> default_config = SolverConfig.from_kwargs(     use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED, initial_omega_parameters=[2.0, 15.0, 5.0,], initial_detuning_parameters=[-45.0, 0.0, 25.0]), ) solver = QuboSolver(instance, default_config)  solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[0., 0., 1.],\n        [0., 1., 0.],\n        [1., 0., 0.],\n        [0., 0., 0.]]), costs=tensor([-3., -2., -1.,  0.]), counts=tensor([12, 16, 15, 57], dtype=torch.int32), probabilities=tensor([0.1200, 0.1600, 0.1500, 0.5700]), solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre> In\u00a0[\u00a0]: Copied! <pre>default_config = SolverConfig.from_kwargs(\n    use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED, re_execute_opt_pulse=True),\n)\nsolver = QuboSolver(instance, default_config)\n\nsolution = solver.solve()\nprint(solution)\n</pre> default_config = SolverConfig.from_kwargs(     use_quantum=True, pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED, re_execute_opt_pulse=True), ) solver = QuboSolver(instance, default_config)  solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[0., 0., 1.],\n        [0., 1., 0.],\n        [1., 0., 0.],\n        [0., 0., 0.]]), costs=tensor([-3., -2., -1.,  0.]), counts=tensor([ 71,  64,  89, 276], dtype=torch.int32), probabilities=tensor([0.1420, 0.1280, 0.1780, 0.5520]), solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre> In\u00a0[\u00a0]: Copied! <pre>from qubosolver.utils.qubo_eval import calculate_qubo_cost\n\n# example of penalization\ndef penalized_qubo(bitstring: str, QUBO: torch.Tensor) -&gt; float:\n    return calculate_qubo_cost(bitstring, QUBO) + 2 * bitstring.count(\"0\")\n\n# example of saving intermediate results\nopt_results = list()\ndef callback(d: dict) -&gt; None:\n    opt_results.append(d)\n\n# example of using an average cost\ndef average_ojective(\n    bitstrings: list,\n    counts: list,\n    probabilities: list,\n    costs: list,\n    best_cost: float,\n    best_bitstring: str,\n) -&gt; float:\n    return sum([p * c for p, c in zip(probabilities, costs)])\n\npulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED, \n    re_execute_opt_pulse=True, \n    custom_qubo_cost=penalized_qubo, \n    callback_objective=callback,\n    custom_objective = average_ojective,\n)\n\nconfig = SolverConfig(\n    use_quantum=True, \n    pulse_shaping=pulse_shaping,\n)\n</pre> from qubosolver.utils.qubo_eval import calculate_qubo_cost  # example of penalization def penalized_qubo(bitstring: str, QUBO: torch.Tensor) -&gt; float:     return calculate_qubo_cost(bitstring, QUBO) + 2 * bitstring.count(\"0\")  # example of saving intermediate results opt_results = list() def callback(d: dict) -&gt; None:     opt_results.append(d)  # example of using an average cost def average_ojective(     bitstrings: list,     counts: list,     probabilities: list,     costs: list,     best_cost: float,     best_bitstring: str, ) -&gt; float:     return sum([p * c for p, c in zip(probabilities, costs)])  pulse_shaping=PulseShapingConfig(pulse_shaping_method=PulseType.OPTIMIZED,      re_execute_opt_pulse=True,      custom_qubo_cost=penalized_qubo,      callback_objective=callback,     custom_objective = average_ojective, )  config = SolverConfig(     use_quantum=True,      pulse_shaping=pulse_shaping, ) In\u00a0[\u00a0]: Copied! <pre>solver = QuboSolver(instance, config)\nsolution = solver.solve()\nlen(opt_results), opt_results[-1]\n</pre> solver = QuboSolver(instance, config) solution = solver.solve() len(opt_results), opt_results[-1] Out[\u00a0]: <pre>(20,\n {'x': [1.784928590509922,\n   8.110880628177934,\n   7.507619225411378,\n   -121.60698017231257,\n   -1.6642490558873106,\n   -125.66370514359173],\n  'cost_eval': 4.83})</pre> In\u00a0[\u00a0]: Copied! <pre>solution\n</pre> solution Out[\u00a0]: <pre>QUBOSolution(bitstrings=tensor([[0., 0., 1.],\n        [0., 1., 0.],\n        [1., 0., 0.],\n        [0., 0., 0.]]), costs=tensor([-3., -2., -1.,  0.]), counts=tensor([162, 178, 156,   4], dtype=torch.int32), probabilities=tensor([0.3240, 0.3560, 0.3120, 0.0080]), solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)</pre>"},{"location":"tutorial/05-pulse-shaping-methods/#demo-pulse-shaping-methods","title":"Demo - Pulse Shaping Methods\u00b6","text":"<p>In this notebook, we show how to use different pulse shaping methods.</p> <p>Here, the two available pulse shaping methods are shown:</p> <ul> <li><code>ADIABATIC</code> (Has no parameters to be customized).</li> <li><code>OPTIMIZED</code> (Has three parameters that can be customized).</li> </ul> <p>We choose the method when defining the configurations, with <code>pulse_shaping_method = PulseType.(method)</code></p>"},{"location":"tutorial/05-pulse-shaping-methods/#default-config-parameters","title":"Default config parameters:\u00b6","text":"<ul> <li>use_quantum: bool | None = False (for using the pulse shaping methods, we have to set it to <code>True</code>.)</li> <li>backend: str | BackendType = BackendType.QUTIP (possibly can be replace by <code>BackendType.EMU_MPS</code> or any value in <code>BackendType</code>)</li> <li>device: str | DeviceType | None = DeviceType.DIGITAL_ANALOG_DEVICE (also available: <code>ANALOG_DEVICE</code>)</li> <li>embedding_method: str | EmbedderType | None = EmbedderType.GREEDY (also available: <code>BLADE</code>)</li> <li>pulse_shaping_method: str | PulseType | None = PulseType.ADIABATIC (also available: <code>OPTIMIZED</code>)</li> </ul>"},{"location":"tutorial/05-pulse-shaping-methods/#optimized-pulse-shaping-parameters","title":"OPTIMIZED pulse shaping parameters:\u00b6","text":"<ul> <li>re_execute_opt_pulse: bool = False (<code>True</code>) Whether we take the last pulse and make another optimization round following the pipeline (execute) or just take the results of the last one</li> <li>n_calls: Number of optimization rounds; default is 20 and minimum is 12.</li> <li>initial_omega_parameters: [5.0, 10.0, 5.0,] List with initial values for Amplitude (5.0, 10, 5.0) when using Optimized Pulse</li> <li>initial_detuning_parameters: [-10.0, 0.0, 10.0] List with initial values for Detuning (-10.0, 0.0, 10.0) when using Optimized Pulse</li> </ul>"},{"location":"tutorial/05-pulse-shaping-methods/#load-the-instance-as-a-quboinstance-object","title":"Load the instance as a <code>QUBOInstance</code> object\u00b6","text":"<p>Here, we have a 3x3 QUBO matrix with negative diagonal and positive off-diagonal terms.</p>"},{"location":"tutorial/05-pulse-shaping-methods/#standard-adiabatic","title":"Standard Adiabatic\u00b6","text":"<p>Default method</p>"},{"location":"tutorial/05-pulse-shaping-methods/#optimized-pulse-shaping","title":"Optimized Pulse shaping\u00b6","text":""},{"location":"tutorial/05-pulse-shaping-methods/#parameters-to-customize","title":"Parameters to customize:\u00b6","text":"<p>For the OPTIMIZED pulse shaping, we have the following parameters:</p> <ul> <li>n_calls</li> <li>re_execute_opt_pulse</li> <li>initial_omega_parameters</li> <li>initial_detuning_parameters</li> </ul>"},{"location":"tutorial/05-pulse-shaping-methods/#default-configuration","title":"Default configuration\u00b6","text":""},{"location":"tutorial/05-pulse-shaping-methods/#changing-n_calls","title":"Changing n_calls\u00b6","text":""},{"location":"tutorial/05-pulse-shaping-methods/#changing-initial_omega_parameters-and-initial_detuning_parameters","title":"Changing initial_omega_parameters and initial_detuning_parameters\u00b6","text":""},{"location":"tutorial/05-pulse-shaping-methods/#changing-re_execute_opt_pulse-to-true","title":"Changing re_execute_opt_pulse to True\u00b6","text":""},{"location":"tutorial/05-pulse-shaping-methods/#adding-custom-functions","title":"Adding custom functions\u00b6","text":"<p>One can change the pulse shaping method by incorporating custom functions for:</p> <ul> <li>Evaluating a candidate bitstring and QUBO via <code>custom_qubo_cost</code></li> <li>Performing optimization with a different objective than the best cost via <code>custom_objective</code></li> <li>Adding callback functions via <code>callback_objective</code>.</li> </ul>"},{"location":"tutorial/06-classical-heuristics/","title":"Classical Heuristics","text":"In\u00a0[\u00a0]: Copied! <pre>from qubosolver import QUBOInstance\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.config import SolverConfig, ClassicalConfig\n\nqubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]])\nconfig = SolverConfig(use_quantum = False, classical=ClassicalConfig(classical_solver_type=\"dwave_tabu\"))\n\nsolver = QuboSolver(qubo, config)\n\nsolution = solver.solve()\nprint(solution)\n</pre> from qubosolver import QUBOInstance from qubosolver.solver import QuboSolver from qubosolver.config import SolverConfig, ClassicalConfig  qubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]]) config = SolverConfig(use_quantum = False, classical=ClassicalConfig(classical_solver_type=\"dwave_tabu\"))  solver = QuboSolver(qubo, config)  solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[1., 1.]]), costs=tensor([-2.]), counts=None, probabilities=None, solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre> In\u00a0[\u00a0]: Copied! <pre>from qubosolver import QUBOInstance\nfrom qubosolver.solver import QuboSolver\nfrom qubosolver.config import SolverConfig\n\nqubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]])\nconfig = SolverConfig(use_quantum = False, classical=ClassicalConfig(classical_solver_type=\"dwave_sa\"))\n\nsolver = QuboSolver(qubo, config)\n\nsolution = solver.solve()\nprint(solution)\n</pre> from qubosolver import QUBOInstance from qubosolver.solver import QuboSolver from qubosolver.config import SolverConfig  qubo = QUBOInstance(coefficients=[[-2.0, 1.0], [1.0, -2.0]]) config = SolverConfig(use_quantum = False, classical=ClassicalConfig(classical_solver_type=\"dwave_sa\"))  solver = QuboSolver(qubo, config)  solution = solver.solve() print(solution) <pre>QUBOSolution(bitstrings=tensor([[1., 1.]]), costs=tensor([-2.]), counts=None, probabilities=None, solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre>"},{"location":"tutorial/06-classical-heuristics/#quickstart-solving-a-qubo-with-tabu-search","title":"Quickstart: Solving a QUBO with Tabu Search\u00b6","text":"<p>This tutorial shows how to solve a QUBO problem using the Tabu Search solver.</p>"},{"location":"tutorial/06-classical-heuristics/#quickstart-solving-a-qubo-with-simulated-annealing","title":"Quickstart: Solving a QUBO with Simulated Annealing\u00b6","text":"<p>This tutorial shows how to solve a QUBO problem using the Simulated Annealing solver.</p>"},{"location":"tutorial/07-classical-cplex/","title":"CPLEX","text":"In\u00a0[\u00a0]: Copied! <pre>import torch\nfrom qubosolver import QUBOInstance\nfrom qubosolver.config import SolverConfig, ClassicalConfig\nfrom qubosolver.solver import QuboSolver\n\ncoefficients = torch.load(\"qubo_size_15.pt\")\ninstance = QUBOInstance(coefficients)\n\n# Create a SolverConfig object with classical solver options.\ncplex = ClassicalConfig(\n    classical_solver_type=\"cplex\",\n    cplex_maxtime = 600.0, \n    cplex_log_path= \"cplex.log\"  \n)\nconfig = SolverConfig(\n    classical=cplex,  \n)\n# Instantiate the qubo (classical) solver class.\nclassical_solver = QuboSolver(instance, config)\n\n# Solve the QUBO problem and print the solution.\nsolution = classical_solver.solve()\nprint(\"Solution result:\", solution)\n</pre> import torch from qubosolver import QUBOInstance from qubosolver.config import SolverConfig, ClassicalConfig from qubosolver.solver import QuboSolver  coefficients = torch.load(\"qubo_size_15.pt\") instance = QUBOInstance(coefficients)  # Create a SolverConfig object with classical solver options. cplex = ClassicalConfig(     classical_solver_type=\"cplex\",     cplex_maxtime = 600.0,      cplex_log_path= \"cplex.log\"   ) config = SolverConfig(     classical=cplex,   ) # Instantiate the qubo (classical) solver class. classical_solver = QuboSolver(instance, config)  # Solve the QUBO problem and print the solution. solution = classical_solver.solve() print(\"Solution result:\", solution)  <pre>Solution result: QUBOSolution(bitstrings=tensor([[1., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 1., 0., 1., 0.]]), costs=tensor([-273.9201]), counts=None, probabilities=None, solution_status=&lt;SolutionStatusType.UNPROCESSED: 'unprocessed'&gt;)\n</pre>"},{"location":"tutorial/07-classical-cplex/#solve-a-qubo-with-cplex","title":"Solve a QUBO with CPLEX\u00b6","text":"<p>Default CPLEX parameters:</p> <ul> <li>cplex_maxtime (float): <code>600.0</code></li> <li>cplex_log_path (str): <code>\"solver.log\"</code></li> <li>do_preprocessing (bool): <code>False</code></li> <li>do_postprocessing (bool): <code>False</code></li> </ul> <p>Note: Although preprocessing and postprocessing can be enabled, CPLEX is usually powerful enough to solve the QUBO sizes we handle without them.</p>"},{"location":"tutorial/08-qubo_analyzer/","title":"Qubo Analyzer","text":"In\u00a0[\u00a0]: Copied! <pre>import torch\nfrom qubosolver.utils import calculate_density, classify_density\n</pre> import torch from qubosolver.utils import calculate_density, classify_density In\u00a0[\u00a0]: Copied! <pre>from qubosolver.qubo_instance import QUBOInstance\nfrom qubosolver.qubo_analyzer import QUBOAnalyzer\nfrom qubosolver.data import QUBOSolution\n</pre> from qubosolver.qubo_instance import QUBOInstance from qubosolver.qubo_analyzer import QUBOAnalyzer from qubosolver.data import QUBOSolution In\u00a0[\u00a0]: Copied! <pre>num_bitstrings=100\nbit_length=3\n\ncosts = torch.randint(1, 20, (2**bit_length,), dtype=torch.float)\n\nbitstrings = torch.randint(0, 2, (num_bitstrings, bit_length))\nbitstrings,counts=bitstrings.unique(dim=0,return_counts=True)\nsolution1 = QUBOSolution(bitstrings, costs, counts)\n\nbitstrings = torch.randint(0, 2, (num_bitstrings, bit_length))\nbitstrings,counts=bitstrings.unique(dim=0,return_counts=True)\nsolution2 = QUBOSolution(bitstrings, costs, counts)\n</pre> num_bitstrings=100 bit_length=3  costs = torch.randint(1, 20, (2**bit_length,), dtype=torch.float)  bitstrings = torch.randint(0, 2, (num_bitstrings, bit_length)) bitstrings,counts=bitstrings.unique(dim=0,return_counts=True) solution1 = QUBOSolution(bitstrings, costs, counts)  bitstrings = torch.randint(0, 2, (num_bitstrings, bit_length)) bitstrings,counts=bitstrings.unique(dim=0,return_counts=True) solution2 = QUBOSolution(bitstrings, costs, counts)  In\u00a0[\u00a0]: Copied! <pre># Create the analyzer with our two solutions\nanalyzer = QUBOAnalyzer([solution1, solution2], labels=[\"sol1\", \"sol2\"])\n</pre> # Create the analyzer with our two solutions analyzer = QUBOAnalyzer([solution1, solution2], labels=[\"sol1\", \"sol2\"]) In\u00a0[\u00a0]: Copied! <pre>df = analyzer.df\nprint(\"Combined DataFrame:\")\nprint(df)\n</pre> df = analyzer.df print(\"Combined DataFrame:\") print(df) <pre>Combined DataFrame:\n   labels bitstrings  costs  counts  probs\n0    sol1        000    4.0      14   0.14\n1    sol1        001    3.0      11   0.11\n2    sol1        010   17.0      12   0.12\n3    sol1        011   15.0      12   0.12\n4    sol1        100   10.0       6   0.06\n5    sol1        101    2.0      17   0.17\n6    sol1        110    6.0      13   0.13\n7    sol1        111    3.0      15   0.15\n8    sol2        000    4.0      12   0.12\n9    sol2        001    3.0      11   0.11\n10   sol2        010   17.0      12   0.12\n11   sol2        011   15.0       9   0.09\n12   sol2        100   10.0      12   0.12\n13   sol2        101    2.0      18   0.18\n14   sol2        110    6.0      12   0.12\n15   sol2        111    3.0      14   0.14\n</pre> In\u00a0[\u00a0]: Copied! <pre>filtered_cost_df = analyzer.filter_by_cost(max_cost=10)\nprint(\"DataFrame after filtering by cost (&lt;10):\")\nprint(filtered_cost_df)\n</pre> filtered_cost_df = analyzer.filter_by_cost(max_cost=10) print(\"DataFrame after filtering by cost (&lt;10):\") print(filtered_cost_df) <pre>DataFrame after filtering by cost (&lt;10):\n   labels bitstrings  costs  counts  probs\n0    sol1        000    4.0      14   0.14\n1    sol1        001    3.0      11   0.11\n5    sol1        101    2.0      17   0.17\n6    sol1        110    6.0      13   0.13\n7    sol1        111    3.0      15   0.15\n8    sol2        000    4.0      12   0.12\n9    sol2        001    3.0      11   0.11\n13   sol2        101    2.0      18   0.18\n14   sol2        110    6.0      12   0.12\n15   sol2        111    3.0      14   0.14\n</pre> In\u00a0[\u00a0]: Copied! <pre># Filter by percentage: keep top 10% (lowest cost) bitstrings per solution\nfiltered_percent_df = analyzer.filter_by_percentage(column=\"probs\",order=\"descending\",top_percent=0.1)\nprint(\"DataFrame after filtering by top 10% (by cost):\")\nfiltered_percent_df\n</pre> # Filter by percentage: keep top 10% (lowest cost) bitstrings per solution filtered_percent_df = analyzer.filter_by_percentage(column=\"probs\",order=\"descending\",top_percent=0.1) print(\"DataFrame after filtering by top 10% (by cost):\") filtered_percent_df <pre>DataFrame after filtering by top 10% (by cost):\n</pre> Out[\u00a0]: labels bitstrings costs counts probs 0 sol1 101 2.0 17 0.17 1 sol2 101 2.0 18 0.18 In\u00a0[\u00a0]: Copied! <pre># Filter by probability: choose a threshold (here 0.4, for example)\n# (Probabilities are computed from counts for each solution.)\nfiltered_prob_df = analyzer.filter_by_probability(min_probability=0.01)\nprint(\"DataFrame after filtering by probability:\")\nprint(filtered_prob_df)\n</pre> # Filter by probability: choose a threshold (here 0.4, for example) # (Probabilities are computed from counts for each solution.) filtered_prob_df = analyzer.filter_by_probability(min_probability=0.01) print(\"DataFrame after filtering by probability:\") print(filtered_prob_df) <pre>DataFrame after filtering by probability:\n   labels bitstrings  costs  counts  probs\n0    sol1        000    4.0      14   0.14\n1    sol1        001    3.0      11   0.11\n2    sol1        010   17.0      12   0.12\n3    sol1        011   15.0      12   0.12\n4    sol1        100   10.0       6   0.06\n5    sol1        101    2.0      17   0.17\n6    sol1        110    6.0      13   0.13\n7    sol1        111    3.0      15   0.15\n8    sol2        000    4.0      12   0.12\n9    sol2        001    3.0      11   0.11\n10   sol2        010   17.0      12   0.12\n11   sol2        011   15.0       9   0.09\n12   sol2        100   10.0      12   0.12\n13   sol2        101    2.0      18   0.18\n14   sol2        110    6.0      12   0.12\n15   sol2        111    3.0      14   0.14\n</pre> In\u00a0[\u00a0]: Copied! <pre>avg_cost_df = analyzer.average_cost()\nprint(\"Average cost for all bitstrings per solution:\")\nprint(avg_cost_df)\n\nprint('------------------------------------------------')\navg_cost_df = analyzer.average_cost(0.5)\nprint(\"Average cost for top 50% bitstrings per solution:\")\nprint(avg_cost_df)\n\nprint('------------------------------------------------')\navg_cost_df = analyzer.average_cost(0.1)\nprint(\"Average cost for top 10% bitstrings per solution:\")\nprint(avg_cost_df)\nprint('------------------------------------------------')\navg_cost_df = analyzer.average_cost(0.01)\nprint(\"Average cost for top 1% bitstrings per solution:\")\nprint(avg_cost_df)\n</pre> avg_cost_df = analyzer.average_cost() print(\"Average cost for all bitstrings per solution:\") print(avg_cost_df)  print('------------------------------------------------') avg_cost_df = analyzer.average_cost(0.5) print(\"Average cost for top 50% bitstrings per solution:\") print(avg_cost_df)  print('------------------------------------------------') avg_cost_df = analyzer.average_cost(0.1) print(\"Average cost for top 10% bitstrings per solution:\") print(avg_cost_df) print('------------------------------------------------') avg_cost_df = analyzer.average_cost(0.01) print(\"Average cost for top 1% bitstrings per solution:\") print(avg_cost_df) <pre>Average cost for all bitstrings per solution:\n  labels  average cost  bitstrings considered\n0   sol1           7.5                      8\n1   sol2           7.5                      8\n------------------------------------------------\nAverage cost for top 50% bitstrings per solution:\n  labels  average cost  bitstrings considered\n0   sol1           3.0                      4\n1   sol2           3.0                      4\n------------------------------------------------\nAverage cost for top 10% bitstrings per solution:\n  labels  average cost  bitstrings considered\n0   sol1           2.0                      1\n1   sol2           2.0                      1\n------------------------------------------------\nAverage cost for top 1% bitstrings per solution:\n  labels  average cost  bitstrings considered\n0   sol1           2.0                      1\n1   sol2           2.0                      1\n</pre> In\u00a0[\u00a0]: Copied! <pre>best_bit_df = analyzer.best_bitstrings()\nprint(\"Best bitstring per solution:\")\nprint(best_bit_df)\n</pre> best_bit_df = analyzer.best_bitstrings() print(\"Best bitstring per solution:\") print(best_bit_df)  <pre>Best bitstring per solution:\n  labels bitstrings  costs  counts  probs\n0   sol1        101    2.0      17   0.17\n1   sol2        101    2.0      18   0.18\n</pre> In\u00a0[\u00a0]: Copied! <pre>df_with_gaps = analyzer.calculate_gaps(opt_cost=10)\nprint(\"DataFrame after calculating gaps (opt_cost=10):\")\nprint(df_with_gaps)\n</pre> df_with_gaps = analyzer.calculate_gaps(opt_cost=10) print(\"DataFrame after calculating gaps (opt_cost=10):\") print(df_with_gaps) <pre>DataFrame after calculating gaps (opt_cost=10):\n   labels bitstrings  costs  counts  probs  gaps\n0    sol1        000    4.0      14   0.14   0.6\n1    sol1        001    3.0      11   0.11   0.7\n2    sol1        010   17.0      12   0.12   0.7\n3    sol1        011   15.0      12   0.12   0.5\n4    sol1        100   10.0       6   0.06   0.0\n5    sol1        101    2.0      17   0.17   0.8\n6    sol1        110    6.0      13   0.13   0.4\n7    sol1        111    3.0      15   0.15   0.7\n8    sol2        000    4.0      12   0.12   0.6\n9    sol2        001    3.0      11   0.11   0.7\n10   sol2        010   17.0      12   0.12   0.7\n11   sol2        011   15.0       9   0.09   0.5\n12   sol2        100   10.0      12   0.12   0.0\n13   sol2        101    2.0      18   0.18   0.8\n14   sol2        110    6.0      12   0.12   0.4\n15   sol2        111    3.0      14   0.14   0.7\n</pre> In\u00a0[\u00a0]: Copied! <pre># Filter by percentage: keep top 10% (lowest cost) bitstrings per solution\nfiltered_percent_df = analyzer.filter_by_percentage(column=\"gaps\",top_percent=0.1)\nprint(\"DataFrame after filtering by top 10% (by cost):\")\nprint(filtered_percent_df)\n</pre> # Filter by percentage: keep top 10% (lowest cost) bitstrings per solution filtered_percent_df = analyzer.filter_by_percentage(column=\"gaps\",top_percent=0.1) print(\"DataFrame after filtering by top 10% (by cost):\") print(filtered_percent_df) <pre>DataFrame after filtering by top 10% (by cost):\n  labels bitstrings  costs  counts  probs  gaps\n0   sol1        100   10.0       6   0.06   0.0\n1   sol1        110    6.0      13   0.13   0.4\n2   sol2        100   10.0      12   0.12   0.0\n</pre> In\u00a0[\u00a0]: Copied! <pre>plot1 = analyzer.plot(\n    x_axis=\"bitstrings\",\n    y_axis=\"probs\",\n    sort_by=\"probs\",\n    sort_order=\"ascending\",\n    context=\"notebook\"\n)\n</pre> plot1 = analyzer.plot(     x_axis=\"bitstrings\",     y_axis=\"probs\",     sort_by=\"probs\",     sort_order=\"ascending\",     context=\"notebook\" ) <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre> In\u00a0[\u00a0]: Copied! <pre>plot2 = analyzer.plot(\n    x_axis=\"costs\",\n    y_axis=\"probs\",\n    sort_by=\"costs\",\n    sort_order=\"ascending\",\n    context=\"notebook\"\n)\n</pre> plot2 = analyzer.plot(     x_axis=\"costs\",     y_axis=\"probs\",     sort_by=\"costs\",     sort_order=\"ascending\",     context=\"notebook\" ) <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre> In\u00a0[\u00a0]: Copied! <pre>plot2 = analyzer.plot(\n    x_axis=\"costs\",\n    y_axis=\"probs\",\n    sort_by=\"costs\",\n    sort_order=\"ascending\",\n    probability_threshold=0.1,\n    context=\"notebook\"\n)\n</pre> plot2 = analyzer.plot(     x_axis=\"costs\",     y_axis=\"probs\",     sort_by=\"costs\",     sort_order=\"ascending\",     probability_threshold=0.1,     context=\"notebook\" ) <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre> In\u00a0[\u00a0]: Copied! <pre>plot2 = analyzer.plot(\n    x_axis=\"costs\",\n    y_axis=\"probs\",\n    sort_by=\"costs\",\n    sort_order=\"ascending\",\n    cost_threshold=11,\n    context=\"notebook\"\n)\n</pre> plot2 = analyzer.plot(     x_axis=\"costs\",     y_axis=\"probs\",     sort_by=\"costs\",     sort_order=\"ascending\",     cost_threshold=11,     context=\"notebook\" ) <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre> In\u00a0[\u00a0]: Copied! <pre>plot2 = analyzer.plot(\n    x_axis=\"costs\",\n    y_axis=\"probs\",\n    sort_by=\"costs\",\n    sort_order=\"ascending\",\n    top_percent=0.1,\n    context=\"notebook\"\n)\n</pre> plot2 = analyzer.plot(     x_axis=\"costs\",     y_axis=\"probs\",     sort_by=\"costs\",     sort_order=\"ascending\",     top_percent=0.1,     context=\"notebook\" ) <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre> In\u00a0[\u00a0]: Copied! <pre>plot2 = analyzer.plot(\n    x_axis=\"costs\",\n    y_axis=\"probs\",\n    sort_by=\"costs\",\n    sort_order=\"ascending\",\n    labels=['sol1'],\n    context=\"notebook\"\n)\n</pre> plot2 = analyzer.plot(     x_axis=\"costs\",     y_axis=\"probs\",     sort_by=\"costs\",     sort_order=\"ascending\",     labels=['sol1'],     context=\"notebook\" ) <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre> In\u00a0[\u00a0]: Copied! <pre># Create a new solution with different bitstrings and costs\nbitstrings = torch.randint(0, 2, (5, bit_length))\nbitstrings,counts=bitstrings.unique(dim=0,return_counts=True)\ncosts = torch.randint(1, 20, (len(bitstrings),), dtype=torch.float)\nsolution3 = QUBOSolution(bitstrings, costs, counts)\n\n# Create the analyzer with our three solutions\nanalyzer = QUBOAnalyzer([solution1, solution2, solution3], labels=[\"sol1\", \"sol2\", \"sol3\"])\n</pre> # Create a new solution with different bitstrings and costs bitstrings = torch.randint(0, 2, (5, bit_length)) bitstrings,counts=bitstrings.unique(dim=0,return_counts=True) costs = torch.randint(1, 20, (len(bitstrings),), dtype=torch.float) solution3 = QUBOSolution(bitstrings, costs, counts)  # Create the analyzer with our three solutions analyzer = QUBOAnalyzer([solution1, solution2, solution3], labels=[\"sol1\", \"sol2\", \"sol3\"]) In\u00a0[\u00a0]: Copied! <pre># Compare the solutions\nanalyzer.compare_qubo_solutions([\"sol1\", \"sol3\"])\nprint(\"\\n -------------------------------------- \\n\")\nanalyzer.compare_qubo_solutions([\"sol1\", \"sol2\"])\n</pre> # Compare the solutions analyzer.compare_qubo_solutions([\"sol1\", \"sol3\"]) print(\"\\n -------------------------------------- \\n\") analyzer.compare_qubo_solutions([\"sol1\", \"sol2\"]) <pre>Comparing two lists of bitstrings:\n1. sol1: 8 bitstrings (8 unique strings)\n2. sol3: 4 bitstrings (4 unique strings)\n\nBitstrings in sol1 not present in sol3:\n- 001\n- 110\n- 101\n- 100\n\nRatio of different bitstrings: 4/8 = 50%\n\n -------------------------------------- \n\nComparing two lists of bitstrings:\n1. sol1: 8 bitstrings (8 unique strings)\n2. sol2: 8 bitstrings (8 unique strings)\n\nThe lists contain exactly the same bitstrings.\n</pre>"}]}